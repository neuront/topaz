include 'src/utils.fls' as utils
include 'src/value_types.fls' as valuet
include 'src/elements.fls' as elemt
include 'src/syntax.fls' as syntax

# http://www.w3.org/TR/2011/WD-html-markup-20110113/syntax.html#void-element
VOID_ELEMENTS: {
    area: true,
    base: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
}

class Builder
    ctor(variables)
        this.varStack: [variables if variables else {}]
        this.templStack: [null]
        this.cachedInclude: {}

    func currentTempl()
        return this.templStack[0]

    func buildAndRenderText(text, %%)
        return this.applyAndRender(this.buildTextToElements(text), %%)

    func buildAndRenderTextSync(text)
        return this.applyAndRenderSync(this.buildTextToElements(text))

    func buildTextToElements(text)
        b: syntax.SyntaxBuilder(this)
        text.split('\n') |: b.addLine($)
        b.finish()
        return b.getElements()

    func applyVariablesTo(elements, %%)
        root: elemt.FakeRoot()
        elements |: root.append($.applyVariables(root, this, 0, %%))
        return root.children

    func applyVariablesToSync(elements)
        root: elemt.FakeRoot()
        elements |: root.append($.applyVariablesSync(root, this))
        return root.children

    func clearCachedInclude()
        this.cachedInclude: {}

    func includeApply(parent, incl, path, variables, %%)
        ifnot this.cachedInclude[path]
            t: this.getTemplate(path, %%)
            if t = undefined || t = null
                incl.throw_('include path ' + path + ' returns ' + t)
            this.templStack.unshift(path)
            this.cachedInclude[path]: this.buildTextToElements(t)
            this.templStack.shift()

        this.varStack.unshift(variables)
        this.cachedInclude[path] |: parent.append($.applyVariables(parent, this, undefined, %%))
        this.varStack.shift()

    func includeApplySync(parent, incl, path, variables)
        ifnot this.cachedInclude[path]
            t: this.getTemplateSync(path)
            if t = undefined || t = null
                incl.throw_('include path ' + path + ' returns ' + t)
            this.templStack.unshift(path)
            this.cachedInclude[path]: this.buildTextToElements(t)
            this.templStack.shift()

        this.varStack.unshift(variables)
        this.cachedInclude[path] |: parent.append($.applyVariablesSync(parent, this))
        this.varStack.shift()

    func getTemplate(path, %%)
        throw 'Builder.getTemplate not implemented'

    func getTemplateSync(path)
        throw 'Builder.getTemplateSync not implemented'

    func renderApplied(elements)
        return (elements |: $.render(this)).join(this.eol())

    func applyAndRender(elements, %%)
        return this.renderApplied(this.applyVariablesTo(elements, %%))

    func applyAndRenderSync(elements)
        return this.renderApplied(this.applyVariablesToSync(elements))

    func _applyDictForData(element, dictVal)
        dictVal |:
            v: $.apply(this)
            if v != undefined && v != null
                element.attr('data-' + $k, v.toString())

    func _applyDictForStyle(element, dictVal)
        element.attr('style', (dictVal |:
            v: $.apply(this)
            if v != undefined && v != null
                $result.push([$k, $.apply(this)].join(':'))
        ).join(';'))

    func applyDictForAttr(element, attr, dictVal)
        if attr = 'data'
            return this._applyDictForData(element, dictVal)
        if attr = 'style'
            return this._applyDictForStyle(element, dictVal)
        return this.applyDictForCustomAttr(element, attr, dictVal)

    func applyDictForCustomAttr(element, attr, dictVal)
        dictVal.throw_('Dict value not handled for ' + attr + ' of ' + element.tag)

    func onTagBegin(element, stack)
        f: utils.findFuncName('_ontagbegin_', element.tag)
        if this[f]
            this[f](element, stack)

    func onTagEnd(element)
        f: utils.findFuncName('_ontagend_', element.tag)
        if this[f]
            this[f](element)

    func onTagApplied(element)
        f: utils.findFuncName('_applied_', element.tag)
        return this[f](element) if this[f] else element

    func setAppliedFunc(tagname, f)
        self: this
        self[utils.findFuncName('_applied_', tagname)]: (element): f(element, self)

    func overrideAttrs(src, dst, overrides, ignore)
        src.attributes |:
            if overrides.hasOwnProperty($k)
                continue
            ifnot ignore[$k]
                dst.attr($k, $)
        overrides |: dst.attr($k, $)

    func repeatStr(s, times)
        if !times
            return ''
        return Array(times + 1).join(s)

    func indent(indentLevel)
        return this.repeatStr(' ', indentLevel)

    func eol()
        return '\n'

    func renderTextLine(element, o, esc)
        return this.indent(element.indentLevel) + esc(element.text)

    func renderTextBlock(element)
        return (element.lines |: element.right(element.left(element.escape($)))).join(element.eol)

    func renderTag(element)
        f: utils.findFuncName('_rendertag_', element.tag)
        if this[f]
            return this[f](element)
        if VOID_ELEMENTS[element.tag]
            element.checkNoChildren()
            return this.renderVoid(element.tag, element)
        return this.renderNonvoid(element.tag, element)

    func renderNonvoid(tag, element)
        return ([this.openTag(tag, element)] ++
                (element.children |: $.render(this)) ++
                [this.closeTag(tag, element.indentLevel)]
               ).join(this.eol())

    func renderVoid(tag, element)
        return this.openTag(tag, element)

    func renderInline(tag, element)
        return this.openTag(tag, element) + this.closeTag(tag)

    func renderInlineWithText(tag, element, text)
        return this.openTag(tag, element) + text + this.closeTag(tag)

    func renderClasses(cls)
        return '' if cls.length = 0 else (' class="' + cls.join(' ') + '"')

    func renderAttrs(attrs)
        return (attrs |:
            if $ != null && $ != undefined
                $result.push(' ', $k, '="', utils.escapeText($.toString()) + '"')
        ).join('')

    func openTag(tag, elm)
        return this.indent(elm.indentLevel) + '<' + tag +
            this.renderClasses(elm.classes) + this.renderAttrs(elm.attributes) + '>'

    func closeTag(tag, indentLevel)
        return this.indent(indentLevel) + '</' + tag + '>'

    func setRenderFunc(tagname, f)
        self: this
        self[utils.findFuncName('_rendertag_', tagname)]: (element): f(element, self)

    func getValue(name)
        return this.varStack[0][name]

    func setValue(name, value)
        this.varStack[0][name]: value

    func resetVariables(variables)
        this.varStack: [variables]
        this.templStack: [null]

class HTMLBasisBuilder: Builder
    ctor(variables) super(variables)
        0

    func _pushTextReceiver(stack, element)
        class ActiveTextBlockAutomation: syntax.TextBlockAutomation
            ctor() super(stack, element, element.pos)
                self: this
                self.addLine: (s): self._add1stLine(s)

            func _add1stLine(string)
                self: this
                indent: utils.indentLv(string)
                if indent < element.indentLevel
                    element.throw_('Invalid content indent level')
                self._lines.push(string)
                self.stack.indentLevel: indent
                self.addLine: (s): self._addLine(s)

            func _addLine(string)
                this._lines.push(string)

        stack.push(ActiveTextBlockAutomation())

    func _ontagbegin_js(element, stack)
        this._pushTextReceiver(stack, element)
        element.tag: 'script'
        element.attributes.type: valuet.LiteralValue(element.pos, 'text/javascript')

    func _ontagbegin_css(element, stack)
        this._pushTextReceiver(stack, element)
        element.tag: 'style'

    func _rendertag_html5(element)
        return (['<!doctype html>', this.openTag('html', element)] ++
                (element.children |: $.render(this))).join(this.eol())

    func _applied_charset(element)
        element.checkNoChildren()
        meta: element.replaceTag('meta')
        charset: element.getOnlyArg(element, 'charset')
        if element.parent && element.parent.parent && element.parent.parent.isTag('html5')
            this.overrideAttrs(element, meta, {charset: charset}, {})
            return meta
        this.overrideAttrs(element, meta, {
            'http-equiv': 'Content-Type',
            content: 'text/html; charset=' + charset,
        }, {})
        return meta

    func _applied_jsfile(element)
        element.checkNoChildren()
        script: element.replaceTag('script')
        this.overrideAttrs(element, script, {
            type: 'text/javascript',
            src: element.getOnlyArg(element, 'file'),
        }, {})
        return script

    func _applied_cssfile(element)
        element.checkNoChildren()
        link: element.replaceTag('link')
        this.overrideAttrs(element, link, {
            rel: 'stylesheet',
            type: 'text/css',
            href: element.getOnlyArg(element, 'file'),
        }, {})
        return link

func renderHTMLBasis(text, variables)
    return HTMLBasisBuilder(variables).buildAndRenderTextSync(text)

export Builder: Builder
export HTMLBasisBuilder: HTMLBasisBuilder
export renderHTMLBasis: renderHTMLBasis

# Bootstrap & Font-awesome builder

class BootstrapFontawesomeBuilder: HTMLBasisBuilder
    ctor(variables) super(variables)
        0

    func overrideAttrsAsInput(src, dst, overrides, ignore)
        ignore.disabled: true
        this.overrideAttrs(src, dst, overrides, ignore)
        if src.argsKey.disabled || src.attributes.disabled
            dst.attr('disabled', 'disabled')

    func overrideAttrsAsBtn(src, dst, overrides, ignore)
        ignore.color: true
        overrides.type: src.attributes.type if src.attributes.type else 'button'
        this.overrideAttrsAsInput(src, dst, overrides, ignore)
        dst.addClass('btn')
        dst.addClass('btn-' + (src.attributes.color if src.attributes.color else 'default'))

    func _applied_btn(element)
        btn: element.replaceTag('button')
        this.overrideAttrsAsBtn(element, btn, {}, {})
        return btn

    func overrideAttrsAsFormCtl(src, dst, overrides, ignore)
        this.overrideAttrsAsInput(src, dst, overrides, ignore)
        dst.addClass('form-control')

    func _applied_input(element)
        i: element.replaceTag('input')
        this.overrideAttrsAsFormCtl(element, i, {type: 'text'}, {})
        return i

    func _applied_passwd(element)
        i: element.replaceTag('input')
        this.overrideAttrsAsFormCtl(element, i, {type: 'password'}, {})
        return i

    func _applied_textarea(element)
        i: element.replaceTag('textarea')
        this.overrideAttrsAsFormCtl(element, i, {}, {})
        return i

    func _applied_select(element)
        i: element.replaceTag('select')
        this.overrideAttrsAsFormCtl(element, i, {}, {})
        return i

    func _checkBoxApplied(element)
        self: this

        func inline()
            label: elemt.AppliedTagElement(element.parent, element.indentLevel,
                                           element.pos, 'label')
            label.addClass(element.tag + '-inline')
            input: element.replaceTag('input')
            input.indentLevel: label.indentLevel + 1 if input.children.length = 0
                                                     else input.children[0].indentLevel
            self.overrideAttrsAsInput(element, input, {type: element.tag}, {})
            label.append(input)
            input.children |: label.append($)
            input.children: []
            return label

        func block()
            root: elemt.AppliedTagElement(element.parent, element.indentLevel, element.pos, 'div')
            root.addClass(element.tag)
            if element.argsKey.disabled
                root.addClass('disabled')
            label: elemt.AppliedTagElement(element.parent, root.indentLevel + 1,
                                           element.pos, 'label')
            input: element.replaceTag('input')
            input.indentLevel: label.indentLevel + 1 if input.children.length = 0
                                                     else input.children[0].indentLevel
            self.overrideAttrsAsInput(element, input, {type: element.tag}, {})
            label.append(input)
            input.children |: label.append($)
            input.children: []
            root.append(label)
            return root

        return inline() if element.argsKey.inline else block()

    func _applied_checkbox(element)
        return this._checkBoxApplied(element)

    func _applied_radio(element)
        return this._checkBoxApplied(element)

    func _applied_container(element)
        c: element.replaceTag('div')
        c.addClass('container')
        return c

    func _applied_form_h(element)
        c: element.replaceTag('form')
        this.overrideAttrs(element, c, {}, {})
        c.addClass('form-horizontal')
        c.addClass('form-submit')
        return c

    func _applied_row(element)
        c: element.replaceTag('div')
        this.overrideAttrs(element, c, {}, {})
        c.addClass('form-group' if element.parent.isTag('form') ||
                                    element.parent.isTag('form-h') else 'row')
        return c

    func _firstOrCreate(parent, elements, tag, throwMsg)
        if elements.length = 0
            return elemt.AppliedTagElement(parent, parent.indentLevel + 1, parent.pos, tag)
        e: elements[0]
        if elements.length > 1 && throwMsg
            elements[1].throw_(throwMsg)
        return e.replaceTag(tag)

    func _firstOrNull(elements, throwMsg)
        if elements.length = 0
            return null
        e: elements[0]
        if elements.length > 1 && throwMsg
            elements[1].throw_(throwMsg)
        return e

    func _applied_panel(element)
        panel: element.replaceTag('div')
        panel.addClass('panel')
        panel.addClass('panel-' + (element.attributes.color
                                    if element.attributes.color else 'default'))
        this.overrideAttrs(element, panel, {}, {color: true})
        title: this._firstOrNull(panel.sliceChildren('title'), 'more than 1 titles for panel')
        body: this._firstOrCreate(panel, panel.sliceChildren('body'), 'div',
                                  'more than 1 bodies for panel')
        body.addClass('panel-body')
        panel.children |: body.append($)
        panel.children: []
        if title != null
            t: title.replaceTag('div')
            this.overrideAttrs(title, t, {}, {})
            t.addClass('panel-heading')
            panel.append(t)
        panel.append(body)
        return panel

    func _applied_modal(element)
        modal: element.replaceTag('div')
        modal.addClass('modal')
        modal.addClass('fade')
        this.overrideAttrs(element, modal, {
            role: 'dialog',
            tabindex: '-1',
            'aria-labelledby': '',
            'aria-hidden': 'true',
        }, {size: true})

        dialog: elemt.AppliedTagElement(modal, modal.indentLevel + 1, modal.pos, 'div')
        dialog.addClass('modal-dialog')
        dialog.addClass('modal-' + (element.attributes.size if element.attributes.size else 'lg'))
        content: elemt.AppliedTagElement(dialog, dialog.indentLevel + 1, dialog.pos, 'div')
        content.addClass('modal-content')
        dialog.append(content)

        head: this._firstOrCreate(content, modal.sliceChildren('head'), 'div',
                                  'more than 1 heads for modal')
        head.addClass('modal-header')
        content.append(head)

        body: this._firstOrCreate(content, modal.sliceChildren('body'), 'div',
                                  'more than 1 bodies for modal')
        body.addClass('modal-body')
        content.append(body)

        closeBtn: elemt.AppliedTagElement(head, head.indentLevel + 1, head.pos, 'button')
        closeBtn.addClass('close')
        closeBtn.attr('type', 'button')
        closeBtn.attr('data-dismiss', 'modal')
        closeBtn.append(elemt.TextLineElement(closeBtn, closeBtn.indentLevel + 1, closeBtn.pos,
                                              '&times;', (a): a))
        head.append(closeBtn)
        title: this._firstOrNull(modal.sliceChildren('title'), 'more than 1 titles for modal')
        if title != null
            t: title.replaceTag('h4')
            this.overrideAttrs(title, t, {}, {})
            t.addClass('modal-title')
            head.append(t)
        modal.children |: body.append($)
        modal.children: []
        modal.append(dialog)
        return modal

    func _applied_modal_toggle(element)
        toggle: element.replaceTag('button')
        this.overrideAttrsAsBtn(element, toggle, {
            'data-target': '#' + element.attributes.target,
            'data-toggle': 'modal',
        }, {target: true})
        return toggle

    func _applied_icon(element)
        element.checkNoChildren()
        t: element.replaceTag('i')
        t.addClass('fa')
        t.addClass('fa-' + element.getOnlyArg(element, 'icon'))
        return t

    func overrideAttrsAsGrid(src, dst, overrides, ignore)
        ignore.size: true
        ignore.offset: true
        if src.attributes.size > 0
            dst.addClass('col-sm-' + src.attributes.size)
        else
            dst.addClass('col-sm-4')
        if src.attributes.offset > 0
            dst.addClass('col-sm-offset-' + src.attributes.offset)
        this.overrideAttrs(src, dst, overrides, ignore)

    func _applied_grid(element)
        g: element.replaceTag('div')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_grid_s(element)
        g: element.replaceTag('label')
        g.addClass('form-control-static')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_grid_c(element)
        g: element.replaceTag('label')
        g.addClass('control-label')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_lbl(element)
        label: element.replaceTag('span')
        label.addClass('label')
        label.addClass('label-' + (element.attributes.color if element.attributes.color
                                                            else 'default'))
        this.overrideAttrs(element, label, {}, {color: true})
        return label

    func _applied_breadcrumb(element)
        if element.children.length = 0
            return element.replaceTag('div')
        bc: element.replaceTag('ol', false)
        this.overrideAttrs(element, bc, {}, {})
        bc.addClass('breadcrumb')
        for i range element.children.length - 1
            e: element.children[i]
            li: e.wrapReplaceIn('li', 'a')
            this.overrideAttrs(e, li.children[0], {}, {})
            bc.append(li)
        active: element.children[element.children.length - 1].replaceTag('li')
        active.addClass('active')
        bc.append(active)
        return bc

    func overrideAttrsAsAlert(src, dst, overrides, ignore)
        ignore.color: true
        ignore.dismiss: true
        this.overrideAttrs(src, dst, overrides, ignore)

    func _addAlertClasses(src, dst)
        dst.attributes.role: 'alert'
        dst.addClass('alert')
        dst.addClass('alert-' + (src.attributes.color if src.attributes.color else 'warning'))

    func _applyDismissableAlert(element)
        alr: element.wrapReplaceIn('div', 'div')
        this.overrideAttrsAsAlert(element, alr.children[0], {}, {})
        this._addAlertClasses(element, alr)
        alr.addClass('alert-dismissible')
        dismiss: elemt.AppliedTagElement(alr, alr.indentLevel + 1, alr.pos, 'button')
        dismiss.attributes: {
            type: 'button',
            'class': 'close',
            'data-dismiss': 'alert',
            'aria-label': 'Close',
        }
        close: elemt.AppliedTagElement(dismiss, dismiss.indentLevel + 1, dismiss.pos, 'span')
        close.attr('aria-hidden', 'true')
        close.append(elemt.TextLineElement(close, close.indentLevel + 1,
                                           close.pos, '&times;', (a): a))
        dismiss.append(close)
        alr.prepend(dismiss)
        return alr

    func _applied_alert(element)
        if element.argsKey.dismiss || element.attributes.dismiss
            return this._applyDismissableAlert(element)
        alr: element.replaceTag('div')
        this.overrideAttrsAsAlert(element, alr, {}, {})
        this._addAlertClasses(element, alr)
        return alr

func renderBootstrap(text, variables)
    return BootstrapFontawesomeBuilder(variables).buildAndRenderTextSync(text)

export BootstrapFontawesomeBuilder: BootstrapFontawesomeBuilder
export renderBootstrap: renderBootstrap

export __version__: '0.2.0 2015-02-02 Experimental'
