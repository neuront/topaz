class Exception
    ctor(pos, message, type, object)
        this.pos: pos
        this.message: message
        this.type: type
        this.object: object

    func toString()
        return JSON.stringify({
            pos: this.pos,
            message: this.message,
            type: this.type,
            object: this.object,
        })

PATTERNS: [
    [/^[a-z_][0-9a-z_\-]*/i, 'ident'],

    [/^"([^"\\]*(\\.[^"\\]*)*)"/i, 'value', 'str'],
    [/^'([^'\\]*(\\.[^'\\]*)*)'/i, 'value', 'str'],
    [/^[0-9]+/, 'value', 'num'],
    [/^[0-9]*\.[0-9]+/, 'value', 'num'],

    [/^==/, 'op', 'eq'],
    [/^<=/, 'op', 'le'],
    [/^>=/, 'op', 'ge'],
    [/^!=/, 'op', 'ne'],
    [/^</, 'op', 'lt'],
    [/^>/, 'op', 'gt'],

    [/^&&/, 'op', 'and'],
    [/^\|\|/, 'op', 'or'],
    [/^!/, 'op', 'not'],

    [/^\+/, 'op', 'plus'],
    [/^\-/, 'op', 'minus'],
    [/^\*/, 'op', 'times'],
    [/^\//, 'op', 'div'],

    [/^=/, 'eq'],
    [/^#/, 'shp'],
    [/^\./, 'dot'],
    [/^%/, 'percentage'],
    [/^,/, 'comma'],
    [/^:/, 'colon'],

    [/^\(/, 'openparen'],
    [/^\)/, 'closeparen'],
    [/^\[/, 'openbracket'],
    [/^\]/, 'closebracket'],
    [/^\{/, 'openbrace'],
    [/^\}/, 'closebrace'],
]

class Token
    ctor(image, type, detail, pos)
        this.image: image
        this.type: type
        this.detail: detail if detail else type
        this.pos: pos

    func throw_(msg)
        throw Exception(this.pos, msg, 'token', this)

    func unexpected()
        this.throw_('Unexpected')

func tokenize(string, line, templ)
    func tkz(string, result)
        func nextToken(string)
            pos: {line: line, templ: templ}
            PATTERNS |:
                r: $[0].exec(string)
                if r
                    return [Token(r[0], $[1], $[2], pos), string.replace($[0], '').trimLeft()]
            throw Exception(pos, 'Unexpected pattern', 'lex', string)

        if string.length = 0
            return result
        r: nextToken(string)
        result.push(r[0])
        return tkz(r[1], result)
    return tkz(string, [])

func testTrue(a)
    if typeof a = 'boolean'
        return a
    if typeof a = 'number'
        return a != 0 && !isNaN(a)
    a |:
        return true
    return false

func toString(a)
    if a = undefined || a = null
        return a + ''
    return a.toString()

class ValueBase
    ctor(pos)
        this.pos: pos

    func empty()
        return false

    func apply(builder)
        return null

    func applyAsAttr(builder, element, attr)
        return element.attr(attr, this.apply(builder))

    func literal()
        this.throw_('Cannot convert to literal value')

    func test(builder)
        return testTrue(this.apply(builder))

    func throw_(msg)
        throw Exception(this.pos, msg, 'value', this)

class EmptyExpr: ValueBase
    ctor(pos) super(pos)
        0

    func empty()
        return true

class NullValue: ValueBase
    ctor(pos) super(pos)
        0

    func apply()
        return null

class LiteralValue: ValueBase
    ctor(pos, v) super(pos)
        this.value: v

    func apply(builder)
        return this.value

    func literal()
        return this.value

class NameValue: ValueBase
    ctor(pos, n) super(pos)
        this.name: n

    func apply(builder)
        return builder.getValue(this.name, this)

    func literal()
        return this.name

UNARY_OP_FUNC: {
    '+': (a): a,
    '-': (a): -a,
    '!': (a): !testTrue(a),
}

class UnaryOpValue: ValueBase
    ctor(pos, opImage, rhs) super(pos)
        this.op: UNARY_OP_FUNC[opImage]
        this.rhs: rhs

    func apply(builder)
        return this.op(this.rhs.apply(builder))

BINARY_OP_FUNC: {
    '+': (a, b): a + b,
    '-': (a, b): a - b,
    '*': (a, b): a * b,
    '/': (a, b): a / b,
    '%': (a, b): a % b,
    '==': (a, b): a = b,
    '!=': (a, b): a != b,
    '<=': (a, b): a <= b,
    '>=': (a, b): a >= b,
    '<': (a, b): a < b,
    '>': (a, b): a > b,
    '&&': (a, b): b if testTrue(a) else a,
    '||': (a, b): a if testTrue(a) else b,
}

class BinaryOpValue: ValueBase
    ctor(pos, opImage, lhs, rhs) super(pos)
        this.op: BINARY_OP_FUNC[opImage]
        this.lhs: lhs
        this.rhs: rhs

    func apply(builder)
        return this.op(this.lhs.apply(builder), this.rhs.apply(builder))

class MemberAccess: ValueBase
    ctor(pos, lhs, rhs) super(pos)
        this.lhs: lhs
        this.rhs: rhs.literal()

    func apply(builder)
        obj: this.lhs.apply(builder)
        if obj = undefined || obj = null
            this.throw_('Access property ' + this.rhs + ' from ' + obj)
        return obj[this.rhs]

class Lookup: ValueBase
    ctor(pos, lhs, rhs) super(pos)
        this.object: lhs
        this.key: rhs

    func apply(builder)
        obj: this.object.apply(builder)
        key: this.key.apply(builder)
        if obj = undefined || obj = null
            this.throw_('Lookup ' + key + ' from ' + obj)
        return obj[key]

class ListValue: ValueBase
    ctor(pos) super(pos)
        this.list: []

    func apply(builder)
        return this.list |: $.apply(builder)

class DictValue: ValueBase
    ctor(pos) super(pos)
        this.dict: {}

    func apply(builder)
        r: {}
        this.dict |:
            r[$k]: $.apply(builder)
        return r

    func applyAsAttr(builder, element, attr)
        builder.applyDictForAttr(element, attr, this.dict)

class ConditionalValue: ValueBase
    ctor(pos, predicate, consequence, alternative) super(pos)
        this.pred: predicate
        this.consq: consequence
        this.alter: alternative

    func apply(builder)
        return this.consq.apply(builder) if this.pred.test(builder) else this.alter.apply(builder)

class ElementBase
    ctor(parent, indentLevel, pos)
        this.parent: parent
        this.indentLevel: indentLevel
        this.pos: pos

    func append(child)
        this.throw_('Append an element to an unexpected place')

    func prepend(child)
        this.throw_('Prepend an element to an unexpected place')

    func getAppendPoint(child)
        return this

    func render(r)
        this.throw_('Element base not renderable')

    func throw_(msg)
        throw Exception(this.pos, msg, 'element', this)

    func findChildren(tag)
        return []

    func sliceChildren(tag)
        return []

    func isTag(tag)
        return false

    func isText()
        return false

    func attachElse(t)
        t.throw_('Else clause not match an if')

    func finish(builder)
        0

    func applyVariables(parent, builder, newIndent, %%)
        return this.applyVariablesSync(parent, builder, newIndent)

    func applyVariablesSync(parent, builder, newIndent)
        return this

class CompoundElement: ElementBase
    ctor(parent, indentLevel, pos) super(parent, indentLevel, pos)
        this.children: []

    func append(child)
        if child
            this.children.push(child)

    func prepend(child)
        if child
            this.children.unshift(child)

    func getAppendPoint(indentLevel)
        if indentLevel <= this.indentLevel
            return this.parent
        if this.children.length = 0
            return this
        return this.lastChild().getAppendPoint(indentLevel)

    func lastChild()
        return this.children[this.children.length - 1]

    func findChildren(tag)
        return this.children |? $.isTag(tag)

    func sliceChildren(tag)
        r: this.children |? $.isTag(tag)
        this.children: this.children |? !$.isTag(tag)
        return r

    func checkNoChildren()
        if this.children.length != 0
            this.throw_('Unexpected children for void element')

class FakeRoot: CompoundElement
    ctor() super(null, -1, -1)
        this.children: []

    func getAppendPoint(indentLevel)
        if this.children.length = 0
            return this
        return this.lastChild().getAppendPoint(indentLevel)

    func finish(builder)
        if this.children.length != 0
            this.lastChild().finish(builder)

class TagElementBase: CompoundElement
    ctor(parent, indentLevel, pos, tag) super(parent, indentLevel, pos)
        this.tag: tag
        this.attributes: {id: null}
        this.args: []
        this.argsKey: {}
        this.classes: []
        this.children: []

    func isTag(tag)
        return this.tag = tag

    func finish(builder)
        if this.children.length != 0
            this.lastChild().finish(builder)
        builder.onTagEnd(this)

    func getOnlyArg(forwhat)
        ifnot this.args && this.args.length = 1
            this.throw_('Require only one argument: ' + forwhat)
        return this.args[0]

class AppliedTagElement: TagElementBase
    ctor(parent, indentLevel, pos, tag) super(parent, indentLevel, pos, tag)
        0

    func arg(arg)
        if this.argsKey[arg]
            return
        this.args.push(arg)
        this.argsKey[arg]: true

    func attr(key, value)
        this.attributes[key]: value

    func setId(id)
        this.attributes.id: id

    func addClass(cls)
        this.classes.push(cls)

    func applyVariablesSync(p, builder)
        return this

    func render(r)
        return r.renderTag(this)

    func replaceTag(tagName, shiftChildren)
        e: AppliedTagElement(this.parent, this.indentLevel, this.pos, tagName)
        this.classes |: e.addClass($)
        if true if shiftChildren = undefined else shiftChildren
            this.children |: e.append($)
        return e

    func wrapReplaceIn(tagName, replacingTag, shiftChildren)
        p: AppliedTagElement(this.parent, this.indentLevel, this.pos, tagName)
        t: this.replaceTag(replacingTag if replacingTag else this.tag, shiftChildren)
        p.append(t)
        t.parent: p
        return p

class TagElement: TagElementBase
    ctor(parent, indentLevel, pos, tag) super(parent, indentLevel, pos, tag)
        0

    func arg(arg, pos)
        if this.argsKey[arg]
            return
        this.args.push(LiteralValue(pos, arg))
        this.argsKey[arg]: true

    func argExpr(expr)
        this.args.push(expr)

    func _setAttr(key, v)
        if this.attributes[key]
            this.throw_('Duplicate attribute: ' + key)
        this.attributes[key]: v

    func attr(key, value, pos)
        if key = 'class'
            return value.split(' ') |: this.addClass($) if $.length != 0 else 0
        this._setAttr(key, LiteralValue(pos, value))

    func attrExpr(key, expr)
        if key = 'class'
            return this.addClassExpr(expr)
        this._setAttr(key, expr)

    func setId(id, pos)
        this.setIdExpr(LiteralValue(pos, id))

    func setIdExpr(id)
        if this.attributes.id != null
            this.throw_('Duplicate id')
        this.attributes.id: id

    func addClass(cls, pos)
        this.addClassExpr(LiteralValue(pos, cls))

    func addClassExpr(cls)
        this.classes.push(cls)

    func _apply(parent, builder, newIndent)
        element: AppliedTagElement(parent,
                                   this.indentLevel
                                           if newIndent = undefined
                                           else newIndent,
                                   this.pos, this.tag)
        this.attributes |:
            if $
                $.applyAsAttr(builder, element, $k)
        this.args |:
            r: $.apply(builder)
            if r
                element.arg(r)
        this.classes |:
            r: $.apply(builder)
            if r
                element.addClass(r)
        return element

    func applyVariables(parent, builder, newIndent, %%)
        element: this._apply(parent, builder, newIndent)
        this.children |: element.append($.applyVariables(element, builder, $.indentLevel, %%))
        setTimeout(%, 1)
        return builder.onTagApplied(element)

    func applyVariablesSync(parent, builder, newIndent)
        element: this._apply(parent, builder, newIndent)
        this.children |: element.append($.applyVariablesSync(element, builder))
        return builder.onTagApplied(element)

class TextBase: ElementBase
    ctor(parent, indentLevel, pos) super(parent, indentLevel, pos)
        0

    func getAppendPoint(indentLevel)
        return this.parent

    func append(child)
        this.throw_('Unable to append to text')

    func isText()
        return true

class TextLineElement: TextBase
    ctor(parent, indentLevel, pos, text, escape) super(parent, indentLevel, pos)
        this.text: text
        this.escape: escape if escape else escapeText

    func render(r)
        return r.renderTextLine(this, null, this.escape)

class TextBlockElement: TextBase
    ctor(parent, indentLevel, pos, lines, left, right, escape, eol) super(
            parent, indentLevel, pos)
        this.lines: lines
        this.left: left
        this.right: right
        this.escape: escape
        this.eol: eol

    func render(r)
        return r.renderTextBlock(this)

class ValueElement: ElementBase
    ctor(parent, indentLevel, value) super(parent, indentLevel, value.pos)
        this.value: value

    func getAppendPoint(indentLevel)
        return this.parent

    func append(child)
        this.throw_('Unable to append to text')

    func applyVariablesSync(parent, builder, ni)
        value: this.value.apply(builder)
        return TextLineElement(
            this.parent, this.indentLevel if ni = undefined else ni, this.pos, toString(value))

class IfElement: CompoundElement
    ctor(parent, indentLevel, predicate) super(parent, indentLevel, predicate.pos)
        this.predicate: predicate
        this.consequence: this.children
        this.alternative: []

    func applyVariables(parent, builder, ni, %%)
        newIndent: this.indentLevel if ni = undefined else ni
        if this.predicate.test(builder)
            this.consequence |: parent.append($.applyVariables(parent, builder, newIndent, %%))
        else
            this.alternative |: parent.append($.applyVariables(parent, builder, newIndent, %%))
        return null

    func applyVariablesSync(parent, builder, ni)
        newIndent: this.indentLevel if ni = undefined else ni
        if this.predicate.test(builder)
            this.consequence |: parent.append($.applyVariablesSync(parent, builder, newIndent))
        else
            this.alternative |: parent.append($.applyVariablesSync(parent, builder, newIndent))
        return null

    func attachElse(_)
        this.children: this.alternative

class ForElement: CompoundElement
    ctor(parent, indentLevel, keyName, elementName, object) super(parent, indentLevel, object.pos)
        this.keyName: keyName
        this.elementName: elementName
        this.object: object

    func applyVariables(parent, builder, ni, %%)
        newIndent: this.indentLevel if ni = undefined else ni
        this.object.apply(builder) |:
            if this.keyName
                builder.setValue(this.keyName, $k)
            builder.setValue(this.elementName, $)
            this.children |: parent.append($.applyVariables(parent, builder, newIndent, %%))
        return null

    func applyVariablesSync(parent, builder, ni)
        newIndent: this.indentLevel if ni = undefined else ni
        this.object.apply(builder) |:
            if this.keyName
                builder.setValue(this.keyName, $k)
            builder.setValue(this.elementName, $)
            this.children |: parent.append($.applyVariablesSync(parent, builder, newIndent))
        return null

class IncludeElement: ElementBase
    ctor(parent, indentLevel, path, values) super(parent, indentLevel, path.pos)
        this.path: path
        this.values: values

    func getAppendPoint(child)
        return this.parent

    func applyVariables(parent, builder, newIndent, %%)
        builder.includeApply(parent, this, this.path.apply(builder), this.values.apply(builder),
                             %%) |: parent.append($)
        return null

    func applyVariablesSync(parent, builder, newIndent)
        builder.includeApplySync(parent, this, this.path.apply(builder),
                                 this.values.apply(builder)) |: parent.append($)
        return null

class Automation
    ctor(stack)
        this.stack: stack

    func activated()
        0

    func push(token)
        f: '_push_' + token.type
        if this[f]
            return this[f](token)
        token.unexpected()

    func setPushFunc(tokenType, fn)
        self: this
        self['_push_' + tokenType]: (token): fn(self, token)

    func reduced(expr)
        throw 'Unimplemented expr'

    func addLine(string, lineno)
        this.stack.consume(tokenize(string.trim(), lineno, this.stack.templ()))

    func finish()
        this.stack.pop()

    func finished()
        return true

    func forceFinish()
        this.finish()

UNARY_OP_PRI: {
    '!': 2,
    '+': 6,
    '-': 6,
}

BINARY_OP_PRI: {
    '||': 0,
    '&&': 1,

    '==': 3,
    '!=': 3,
    '<=': 3,
    '>=': 3,
    '<': 3,
    '>': 3,

    '+': 4,
    '-': 4,

    '*': 5,
    '/': 5,
    '%': 5,

    '.': 7,
}

KEYWORDS: {
    'for': true,
    'in': true,
    'if': true,
    'else': true,
    'null': true,
    'include': true,
}

class DynamicDataAutomationBase: Automation
    ctor(stack) super(stack)
        0

    func _push_ident(token)
        if KEYWORDS[token.image]
            f: '_pushkw_' + token.image
            if this[f]
                return this[f](token)
            token.type: 'keyword'
            token.detail: 'keyword'
            return token.unexpected()
        this._pushIdent(token)

class ArithAutomation: DynamicDataAutomationBase
    ctor(stack, pos) super(stack)
        this._needFactor: true
        this._exprStack: []
        this._opStack: []
        this.pos: pos
        ['comma', 'closeparen', 'closebracket', 'closebrace'] |: this._setFollowing($)

    func _setFollowing(tokenType)
        this.setPushFunc(tokenType, (self, token): self._finishAt(token))

    func _pushkw_else(token)
        this._finishAt(token)

    func _finishAt(token)
        if this._exprStack.length = 0
            token.unexpected()
        this.finish()
        this.stack.top().push(token)

    func finish()
        this._reduceBinary(-1)
        this.stack.reduced(this._exprStack[0])

    func finished()
        return !this._needFactor

    func forceFinish()
        ifnot this.finished()
            throw Exception(this.pos, 'Unexpected EOF', 'am', this)
        this.finish()

    func _push_dot(token)
        token.type: 'op'
        token.construct: (exprStack):
            rhs: exprStack.shift()
            lhs: exprStack.shift()
            return MemberAccess(token.pos, lhs, rhs)
        return this._push_op(token)

    func _push_percentage(token)
        token.type: 'op'
        return this._push_op(token)

    func _push_op(token)
        if this._needFactor
            return this._pushUnaryOp(token)
        token.construct: token.construct if token.construct else (exprStack):
            rhs: exprStack.shift()
            lhs: exprStack.shift()
            return BinaryOpValue(token.pos, token.image, lhs, rhs)
        token.pri: BINARY_OP_PRI[token.image]
        this._reduceBinary(token.pri)
        this._opStack.unshift(token)
        this._needFactor: true

    func _pushUnaryOp(token)
        pri: UNARY_OP_PRI[token.image]
        if pri = undefined
            token.throw_('Unexpected operator')
        token.pri: pri
        token.construct: (exprStack):
            rhs: exprStack.shift()
            return UnaryOpValue(token.pos, token.image, rhs)
        this._opStack.unshift(token)

    func _reduceBinary(currentOpPri)
        if this._opStack.length = 0
            return
        if this._opStack[0].pri >= currentOpPri
            top: this._opStack.shift()
            this._exprStack.unshift(top.construct(this._exprStack))
            this._reduceBinary(currentOpPri)

    func _pushIdent(token)
        return this._pushFactor(token, NameValue)

    func _push_value(token)
        if token.detail = 'num'
            return this._pushFactor(token, (ln, i): LiteralValue(ln, parseFloat(i)))
        if token.detail = 'str'
            return this._pushFactor(token, (ln, i): LiteralValue(ln, eval(i)))
        return this._pushFactor(token, LiteralValue)

    func _pushValue(value)
        this._needFactor: false
        this._exprStack.unshift(value)

    func _pushFactor(token, construct)
        ifnot this._needFactor
            token.unexpected()
        this._pushValue(construct(token.pos, token.image))

    func _push_openparen(token)
        ifnot this._needFactor
            token.unexpected()
        this.stack.push(ArithWrapAutomation(this.stack, token.pos, 'closeparen', ')'))
        self: this
        self.reduced: (expr): self._pushValue(expr)

    func _push_openbracket(token)
        self: this
        if self._needFactor
            self.reduced: (expr): self._pushValue(expr)
            return this.stack.push(ListAutomation(this.stack, token.pos, 'closebracket', ']'))
        this.stack.push(ArithWrapAutomation(this.stack, token.pos, 'closebracket', ']'))
        this.needFactor: false
        self.reduced: (expr):
            t: Token('.', 'op', 'lookup', token.pos)
            t.construct: (exprStack):
                rhs: exprStack.shift()
                lhs: exprStack.shift()
                return Lookup(token.pos, lhs, rhs)
            self._push_op(t)
            self._pushValue(expr)

    func _push_openbrace(token)
        ifnot this._needFactor
            token.unexpected()
        self: this
        this.reduced: (expr): self._pushValue(expr)
        this.stack.push(DictAutomation(this.stack, token.pos, 'closebrace', '}'))

    func _pushkw_null(token)
        ifnot this._needFactor
            token.unexpected()
        this._pushValue(NullValue(token.pos))

    func _pushkw_if(token)
        if this._needFactor
            token.unexpected()
        this._reduceBinary(-1)
        e: this._exprStack.pop()
        this.stack.push(ConditionalExprAutomation(this.stack, token.pos, e))
        self: this
        self.reduced: (expr): self._pushValue(expr)

class ArithAutomationAllowEmpty: ArithAutomation
    ctor(stack, pos) super(stack, pos)
        0

    func _finishAt(token)
        if this._empty()
            return this.stack.tokenAfterReduced(EmptyExpr(token.pos), token)
        return super._finishAt(token)

    func finish()
        if this._empty()
            return this.stack.reduced(EmptyExpr())
        return super.finish()

    func finished()
        return this._empty() || super.finished()

    func _empty()
        return this._exprStack.length = 0 && this._opStack.length = 0

class ArithWrapAutomation: DynamicDataAutomationBase
    ctor(stack, pos, closerType, closerImage) super(stack)
        this.pos: pos
        this.closeReport: ', expect ' + closerImage
        this.setPushFunc(closerType, (self, token): self.finish())
        this._expr: null

    func activated()
        this.stack.push(ArithAutomation(this.stack, this.pos))

    func reduced(expr)
        this._expr: expr

    func finish()
        this.stack.reduced(this._expr)

    func finished()
        return false

    func _push_closeparen(token)
        token.throw_('Mismatch parenthesis' + this.closeReport)

    func _push_closebracket(token)
        token.throw_('Mismatch parenthesis' + this.closeReport)

    func _push_closebrace(token)
        token.throw_('Mismatch parenthesis' + this.closeReport)

    func forceFinish()
        throw Exception(this.pos, 'Unexpected EOF' + this.closeReport, 'am', this)

class ConditionalExprAutomation: DynamicDataAutomationBase
    ctor(stack, pos, consq) super(stack)
        this.pos: pos
        this._predicate: null
        this._consequence: consq

    func reduced(expr)
        self: this
        self._predicate: expr
        self._pushkw_else: (token):
            self.stack.push(ArithAutomation(self.stack, token.pos))
            self.reduced: (expr): self.finish(expr)

    func activated()
        this.stack.push(ArithAutomation(this.stack, this.pos))

    func finish(expr)
        this.stack.reduced(ConditionalValue(this.pos, this._predicate, this._consequence, expr))

class ListAutomation: ArithWrapAutomation
    ctor(stack, pos, closerType, closerImage) super(stack, pos, closerType, closerImage)
        this._expr: ListValue(pos)

    func activated()
        this.stack.push(ArithAutomationAllowEmpty(this.stack, this.pos))

    func _push_comma()
        this.activated()

    func reduced(expr)
        ifnot expr.empty()
            this._expr.list.push(expr)

class DictItemAutomation: DynamicDataAutomationBase
    ctor(stack, dictVal) super(stack)
        this._name: null
        this._dictVal: dictVal

    func _pushIdent(token)
        this._name: token.image

    func _push_value(token)
        this._name: eval(token.image).toString()

    func _push_colon(token)
        this.stack.push(ArithAutomation(this.stack, token.pos))

    func reduced(expr)
        this._dictVal[this._name]: expr
        this.finish()

    func _push_closebrace(token)
        if this._name = null
            this.finish()
            return this.stack.top().push(token)
        token.throw_('Expect item value')

    func finished()
        return false

class DictAutomation: ArithWrapAutomation
    ctor(stack, pos, closerType, closerImage) super(stack, pos, closerType, closerImage)
        this._expr: DictValue(pos)
        this._key: null

    func activated()
        this.stack.push(DictItemAutomation(this.stack, this._expr.dict))

    func _push_comma()
        this.activated()

class ForHeadAutomation: DynamicDataAutomationBase
    ctor(forToken, stack, parent) super(stack)
        this.forToken: forToken
        this.parent: parent
        this.declares: []
        this._init()

    func _init()
        self: this
        self._pushIdent: (token): self._pushDeclare(token)
        self._push_comma: (token): token.unexpected()

    func _pushkw_in(token)
        if this.declares.length = 0 || this.declares.length > 2
            this.forToken.throw_('For loop expects 1 or 2 declared names, but '
                                 + this.declares.length)
        this.stack.push(ArithAutomation(this.stack, token.pos))

        self: this
        self.reduced: (expr):
            if this.declares.length = 1
                self.parent.append(ForElement(
                            self.parent, self.stack.indentLevel,
                            null, this.declares[0], expr))
            else
                self.parent.append(ForElement(
                            self.parent, self.stack.indentLevel,
                            this.declares[0], this.declares[1], expr))
            self.stack.pop()

    func _waitComma()
        self: this
        self._pushIdent: (token): token.unexpected()
        self._push_comma: (token): self._init()

    func _pushDeclare(token)
        this.declares.push(token.image)
        this._waitComma()

    func finished()
        return false

    func forceFinish()
        this.forToken.throw_('Unexpected end of for loop')

class CtrlFlowAutomation: DynamicDataAutomationBase
    ctor(stack, parent) super(stack)
        this.parent: parent
        this._finished: false
        this._reduced: (_): 0

        ['value', 'op', 'openparen', 'openbracket'] |: this.setPushFunc(
                $, (self, t): self._pushExprAm(t))

    func finished()
        return this._finished

    func _pushkw_if(token)
        self: this
        self.stack.push(ArithAutomation(self.stack, token.pos))
        self._reduced: (expr):
            self.parent.append(IfElement(self.parent, self.stack.indentLevel, expr))
            self._finished: true

    func _pushkw_else(token)
        ifnot this.parent.lastChild()
            token.throw_('Else clause not match an if')
        this.parent.lastChild().attachElse(token)
        this._finished: true

    func _pushkw_for(token)
        this.stack.pop()
        this.stack.push(ForHeadAutomation(token, this.stack, this.parent))

    func _pushkw_include(token)
        this.stack.pop()
        this.stack.push(IncludeAutomation(this.stack, this.parent))

    func _pushExprAm(token)
        self: this
        self.stack.push(ArithAutomation(self.stack, token.pos))
        self._reduced: (expr):
            self.parent.append(ValueElement(self.parent, self.stack.indentLevel, expr))
        self.stack.top().push(token)
        self._finished: true

    func _pushIdent(token)
        this._pushExprAm(token)

    func reduced(expr)
        return this._reduced(expr)

    func forceFinish()
        this.parent.throw_('''Unexpected `%' attached''')

class IncludeAutomation: Automation
    ctor(stack, parent) super(stack)
        this.parent: parent
        this._includePath: null
        this._values: DictValue(0)

    func _setIncludePath(path)
        this._includePath: path
        this._push_ident: (token): token.unexpected()
        this._push_value: (token): token.unexpected()
        this._push_openparen: (token): token.unexpected()

        this.stack.push(ArithAutomationAllowEmpty(this.stack, path.pos))
        self: this
        self.reduced: (expr):
            ifnot expr.empty()
                self._values: expr
            self.finish()

    func _push_ident(token)
        this._setIncludePath(LiteralValue(token.pos, token.image))

    func _push_value(token)
        this._setIncludePath(LiteralValue(token.pos, eval(token.image).toString()))

    func _push_openparen(token)
        self: this
        this.stack.push(ArithWrapAutomation(this.stack, token.pos, 'closeparen', ')'))
        this.reduced: (expr): self._setIncludePath(expr)

    func finish()
        this.parent.append(IncludeElement(this.parent, this.stack.indentLevel,
                                          this._includePath, this._values))
        super.finish()

    func finished()
        return this._includePath != null

    func forceFinish()
        ifnot this.finished()
            this.throw_('Expect include path')

class TagAutomation: Automation
    ctor(stack, element) super(stack)
        this.element: element
        this._lastKey: null
        this._restoreState()

    func reduced(expr)
        self: this
        self._reduced(expr)
        self._reduced: (): self.element.throw_('Unexpected expr')
        self._restoreState()

    func _allowOpenParen(reduced)
        self: this
        self._push_openparen: (token):
            self.stack.push(ArithWrapAutomation(self.stack, token.pos, 'closeparen', ')'))
            self._reduced: reduced

    func _allowOpenBrace(reduced)
        self: this
        self._push_openbrace: (token):
            self.stack.push(DictAutomation(self.stack, token.pos, 'closebrace', '}'))
            self._reduced: reduced

    func _restoreState()
        self: this
        self._forbidAll()
        self._setFinishable()
        self._push_value: (token): self.element.arg(eval(token.image), token.pos)
        self._push_ident: (token): self._pushKey(token)
        self._push_shp: (): self._waitId()
        self._push_dot: (): self._waitClass()
        self._allowOpenParen((expr): self.element.argExpr(expr))

    func _forbidAll()
        this._push_ident: null
        this._push_value: null
        this._push_shp: null
        this._push_dot: null
        this._push_eq: null
        this._push_openparen: null

    func _setUnfinishable(expect)
        self: this
        self._finished: false
        self.finish: (): self.element.throw_('Unexpected end of line, expect ' + expect)

    func _setFinishable()
        self: this
        self._finished: true
        self.finish: (): self._finishAndAppend(false)

    func _finishAndAppend(lastKeyAsArg)
        if lastKeyAsArg
            this.element.arg(this._lastKey.image, this._lastKey.pos)
        super.finish()
        if this.element.parent.children.length != 0
            this.element.parent.lastChild().finish(this.stack.builder)
        this.element.parent.append(this.element)
        this.stack.onTagBegin(this.element)

    func _pushKey(token)
        self: this
        self._forbidAll()
        self._lastKey: token
        self._push_eq: (): self._waitValue()
        self._push_value: (token):
            self.element.arg(self._lastKey.image, this._lastKey.pos)
            self.element.arg(eval(token.image), token.pos)
        self._push_ident: (token):
            self.element.arg(self._lastKey.image, this._lastKey.pos)
            self._pushKey(token)
        self.finish: (): self._finishAndAppend(true)

    func _waitId()
        self: this
        self._forbidAll()
        self._push_ident: (token):
            self.element.setId(token.image, token.pos)
            self._restoreState()
        self._setUnfinishable('ID')
        self._allowOpenParen((expr): self.element.setIdExpr(expr))

    func _waitClass()
        self: this
        self._forbidAll()
        self._push_ident: (token):
            self.element.addClass(token.image, token.pos)
            self._restoreState()
        self._setUnfinishable('class')
        self._allowOpenParen((expr): self.element.addClassExpr(expr))

    func _waitValue()
        self: this
        self._forbidAll()
        self._push_ident: (token):
            self.element.attr(self._lastKey.image, token.image, token.pos)
            self._restoreState()
        self._push_value: (token):
            self.element.attr(self._lastKey.image, eval(token.image), token.pos)
            self._restoreState()
        self._setUnfinishable('attribute value')
        reducedValue: (expr): self.element.attrExpr(self._lastKey.image, expr)
        self._allowOpenParen(reducedValue)
        self._allowOpenBrace(reducedValue)

    func finished()
        return this._finished

    func forceFinish()
        ifnot this.finished()
            this.element.throw_('Unexpected finish of tag')
        this.finish()

_TEXTBLOCK_OPT_FUNCS: {
    left: {
        trim: (am): (ln): ln.trimLeft(),
        trunc: (am): (ln): ln[am.indentLevel, ],
        keep: (am): (ln): ln,
    },
    right: {
        trim: (am): (ln): ln.trimRight(),
        keep: (am): (ln): ln,
    },
    escape: {
        yes: escapeText,
        no: (ln): ln,
    },
    eol: {
        lf: '\n',
        off: '',
        br: '<br>',
    },
}

class TextBlockAutomation: Automation
    ctor(stack, appendPoint, pos, indentLevel, escape) super(stack)
        this.appendPoint: appendPoint
        this.pos: pos
        this.indentLevel: indentLevel
        this._lines: []

        this._props: {
            left: false,
            right: false,
            escape: false,
            eol: false,
        }
        this._funcs: {
            left: _TEXTBLOCK_OPT_FUNCS.left.keep,
            right: _TEXTBLOCK_OPT_FUNCS.right.trim,
            escape: _TEXTBLOCK_OPT_FUNCS.escape['yes' if escape else 'no'],
            eol: _TEXTBLOCK_OPT_FUNCS.eol.lf,
        }
        this._lastProp: null

        this._waitProp()

    func _waitProp()
        self: this
        self._push_ident: (token):
            self._lastProp: token
            self._push_ident: (token): token.unexpected()
        self._push_eq: (token): self._waitValue()

    func _waitValue()
        self: this
        self._push_eq: (token): token.unexpected()
        self._push_ident: (token):
            self._setValue(token)
            self._waitProp()

    func _setValue(token)
        ifnot this._props.hasOwnProperty(this._lastProp.image)
            this._lastProp.throw_('Unknown option for text block')
        if this._props[this._lastProp.image]
            this._lastProp.throw_('Duplicated option for text block')
        this._props[this._lastProp.image]: true
        f: _TEXTBLOCK_OPT_FUNCS[this._lastProp.image][token.image]
        ifnot f
            token.throw_('Invalid option value for text block')
        this._funcs[this._lastProp.image]: f
        this._lastProp: null

    func addLine(string, lineno)
        if this._lastProp != null
            this._lastProp.throw_('Option not set for text block')
        if string.trimLeft() = ':::'
            return this.finish()
        if this.indentLevel = undefined
            this.indentLevel = indentLv(string)
        this._lines.push(string)

    func finish()
        this.appendPoint.append(TextBlockElement(
            this.appendPoint, this.stack.indentLevel, this.pos, this._lines,
            this._funcs.left(this), this._funcs.right(this),
            this._funcs.escape, this._funcs.eol))
        super.finish()

    func finished()
        return false

_TEXTBLOCK_PATTERN: /^:::/
_TEXT_PATTERN: /^:.+$/

class BootstrapAutomation: Automation
    ctor(stack, appendPoint) super(stack)
        this.appendPoint: appendPoint

    func addLine(string, lineno)
        strim: string.trimLeft()
        if _TEXTBLOCK_PATTERN.exec(strim)
            this.stack.push(TextBlockAutomation(
                this.stack, this.appendPoint, lineno, this.stack.indentLevel, true))
            return this.stack.consume(tokenize(strim.slice(3).trim(), lineno, this.stack.templ()))
        if _TEXT_PATTERN.exec(strim)
            return this.appendPoint.append(TextLineElement(
                this.appendPoint, this.stack.indentLevel, lineno, strim.slice(1)))
        super.addLine(string, lineno)

    func _push_ident(token)
        this.stack.push(TagAutomation(this.stack, TagElement(
            this.appendPoint, this.stack.indentLevel, token.pos, token.image)))

    func _push_percentage(token)
        this.stack.push(CtrlFlowAutomation(this.stack, this.appendPoint))

class AutomationStack
    ctor(appendPoint, indentLevel, builder)
        this.indentLevel: indentLevel
        this.stack: [BootstrapAutomation(this, appendPoint)]
        this.builder: builder

    func templ()
        return this.builder.currentTempl()

    func top()
        return this.stack[this.stack.length - 1]

    func push(a)
        this.stack.push(a)
        a.activated()

    func reduced(expr)
        this.pop()
        this.top().reduced(expr)

    func tokenAfterReduced(expr, token)
        this.reduced(expr)
        this.top().push(token)

    func pop()
        return this.stack.pop()

    func consume(tokens)
        tokens |: this.top().push($)

    func addLine(string, pos)
        this.top().addLine(string, pos)

    func tryFinish()
        if this.stack.length = 0
            return true
        if this.top().finished()
            this.top().finish()
            return this.tryFinish()
        return false

    func forceFinish()
        if this.stack.length != 0
            this.top().forceFinish()
            this.forceFinish()

    func onTagBegin(element)
        return this.builder.onTagBegin(element, this)

# http://www.w3.org/TR/2011/WD-html-markup-20110113/syntax.html#void-element
VOID_ELEMENTS: {
    area: true,
    base: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
}

ESCAPE_RE: /[<>'"&]/g
INDENT_RE: *RegExp('^[ ]*')

func escapeText(s)
    return s.replace(ESCAPE_RE, (r): '&#' + r.charCodeAt(0) + ';')

func indentLv(string)
    return INDENT_RE.exec(string)[0].length

func _findFuncName(prefix, tag)
    return prefix + tag.replace(/-/g, '_')

class SyntaxBuilder
    ctor(builder)
        this.builder: builder
        this.lineno: 0
        this._stack: null
        this._root: FakeRoot()

    func getElements()
        return this._root.children

    func _applyStack(indentLevel)
        this._stack: AutomationStack(this.getAppendPoint(indentLevel), indentLevel, this.builder)

    func _initStackIfNull(indentLevel)
        if this._stack = null
            return this._applyStack(indentLevel)
        if indentLevel < this._stack.indentLevel
            this._stack.forceFinish()
            return this._applyStack(indentLevel)

    func getAppendPoint(indentLevel)
        return this._root.getAppendPoint(indentLevel)

    func addLine(string)
        this.lineno: this.lineno + 1
        this._initStackIfNull(indentLv(string))
        this._stack.addLine(string, this.lineno)
        if this._stack.tryFinish()
            this._stack: null

    func finish()
        if this._stack
            this._stack.forceFinish()
        this._root.finish(this.builder)

class Builder
    ctor(variables)
        this.varStack: [variables if variables else {}]
        this.templStack: [null]
        this.cachedInclude: {}

    func currentTempl()
        return this.templStack[0]

    func buildAndRenderText(text, %%)
        return this.applyAndRender(this.buildTextToElements(text), %%)

    func buildAndRenderTextSync(text)
        return this.applyAndRenderSync(this.buildTextToElements(text))

    func buildTextToElements(text)
        b: SyntaxBuilder(this)
        text.split('\n') |: b.addLine($)
        b.finish()
        return b.getElements()

    func applyVariablesTo(elements, %%)
        root: FakeRoot()
        elements |: root.append($.applyVariables(root, this, 0, %%))
        return root.children

    func applyVariablesToSync(elements)
        root: FakeRoot()
        elements |: root.append($.applyVariablesSync(root, this))
        return root.children

    func clearCachedInclude()
        this.cachedInclude: {}

    func includeApply(parent, incl, path, variables, %%)
        ifnot this.cachedInclude[path]
            t: this.includeTemplate(path, %%)
            if t = undefined || t = null
                incl.throw_('include path ' + path + ' returns ' + t)
            this.templStack.unshift(path)
            this.cachedInclude[path]: this.buildTextToElements(t)
            this.templStack.shift()

        this.varStack.unshift(variables)
        this.cachedInclude[path] |: parent.append($.applyVariables(parent, this, undefined, %%))
        this.varStack.shift()

    func includeApplySync(parent, incl, path, variables)
        ifnot this.cachedInclude[path]
            t: this.includeTemplateSync(path)
            if t = undefined || t = null
                incl.throw_('include path ' + path + ' returns ' + t)
            this.templStack.unshift(path)
            this.cachedInclude[path]: this.buildTextToElements(t)
            this.templStack.shift()

        this.varStack.unshift(variables)
        this.cachedInclude[path] |: parent.append($.applyVariablesSync(parent, this))
        this.varStack.shift()

    func includeTemplate(path, %%)
        throw 'Builder.includeTemplate not implemented'

    func includeTemplateSync(path)
        throw 'Builder.includeTemplateSync not implemented'

    func renderApplied(elements)
        return (elements |: $.render(this)).join(this.eol())

    func applyAndRender(elements, %%)
        return this.renderApplied(this.applyVariablesTo(elements, %%))

    func applyAndRenderSync(elements)
        return this.renderApplied(this.applyVariablesToSync(elements))

    func _applyDictForData(element, dictVal)
        dictVal |:
            v: $.apply(this)
            if v != undefined && v != null
                element.attr('data-' + $k, v.toString())

    func _applyDictForStyle(element, dictVal)
        element.attr('style', (dictVal |:
            v: $.apply(this)
            if v != undefined && v != null
                $result.push([$k, $.apply(this)].join(':'))
        ).join(';'))

    func applyDictForAttr(element, attr, dictVal)
        if attr = 'data'
            return this._applyDictForData(element, dictVal)
        if attr = 'style'
            return this._applyDictForStyle(element, dictVal)
        return this.applyDictForCustomAttr(element, attr, dictVal)

    func applyDictForCustomAttr(element, attr, dictVal)
        dictVal.throw_('Dict value not handled for ' + attr + ' of ' + element.tag)

    func onTagBegin(element, stack)
        f: _findFuncName('_ontagbegin_', element.tag)
        if this[f]
            this[f](element, stack)

    func onTagEnd(element)
        f: _findFuncName('_ontagend_', element.tag)
        if this[f]
            this[f](element)

    func onTagApplied(element)
        f: _findFuncName('_applied_', element.tag)
        return this[f](element) if this[f] else element

    func setAppliedFunc(tagname, f)
        self: this
        self[_findFuncName('_applied_', tagname)]: (element): f(element, self)

    func overrideAttrs(src, dst, overrides, ignore)
        src.attributes |:
            if overrides.hasOwnProperty($k)
                continue
            ifnot ignore[$k]
                dst.attr($k, $)
        overrides |: dst.attr($k, $)

    func repeatStr(s, times)
        if !times
            return ''
        return Array(times + 1).join(s)

    func indent(indentLevel)
        return this.repeatStr(' ', indentLevel)

    func eol()
        return '\n'

    func renderTextLine(element, o, esc)
        return this.indent(element.indentLevel) + esc(element.text)

    func renderTextBlock(element)
        return (element.lines |: element.right(element.left(element.escape($)))).join(element.eol)

    func renderTag(element)
        f: _findFuncName('_rendertag_', element.tag)
        if this[f]
            return this[f](element)
        if VOID_ELEMENTS[element.tag]
            element.checkNoChildren()
            return this.renderVoid(element.tag, element)
        return this.renderNonvoid(element.tag, element)

    func renderNonvoid(tag, element)
        return ([this.openTag(tag, element)] ++
                (element.children |: $.render(this)) ++
                [this.closeTag(tag, element.indentLevel)]
               ).join(this.eol())

    func renderVoid(tag, element)
        return this.openTag(tag, element)

    func renderInline(tag, element)
        return this.openTag(tag, element) + this.closeTag(tag)

    func renderInlineWithText(tag, element, text)
        return this.openTag(tag, element) + text + this.closeTag(tag)

    func renderClasses(cls)
        return '' if cls.length = 0 else (' class="' + cls.join(' ') + '"')

    func renderAttrs(attrs)
        return (attrs |:
            if $ != null && $ != undefined
                $result.push(' ', $k, '="', escapeText($.toString()) + '"')
        ).join('')

    func openTag(tag, elm)
        return this.indent(elm.indentLevel) + '<' + tag +
            this.renderClasses(elm.classes) + this.renderAttrs(elm.attributes) + '>'

    func closeTag(tag, indentLevel)
        return this.indent(indentLevel) + '</' + tag + '>'

    func setRenderFunc(tagname, f)
        self: this
        self[_findFuncName('_rendertag_', tagname)]: (element): f(element, self)

    func getValue(name)
        return this.varStack[0][name]

    func setValue(name, value)
        this.varStack[0][name]: value

    func resetVariables(variables)
        this.varStack: [variables]
        this.templStack: [null]

class HTMLBasisBuilder: Builder
    ctor(variables) super(variables)
        0

    func _pushTextReceiver(stack, element)
        class ActiveTextBlockAutomation: TextBlockAutomation
            ctor() super(stack, element, element.pos)
                self: this
                self.addLine: (s): self._add1stLine(s)

            func _add1stLine(string)
                self: this
                indent: indentLv(string)
                if indent < element.indentLevel
                    element.throw_('Invalid content indent level')
                self._lines.push(string)
                self.stack.indentLevel: indent
                self.addLine: (s): self._addLine(s)

            func _addLine(string)
                this._lines.push(string)

        stack.push(ActiveTextBlockAutomation())

    func _ontagbegin_js(element, stack)
        this._pushTextReceiver(stack, element)
        element.tag: 'script'
        element.attributes.type: LiteralValue(element.pos, 'text/javascript')

    func _ontagbegin_css(element, stack)
        this._pushTextReceiver(stack, element)
        element.tag: 'style'

    func _rendertag_html5(element)
        return (['<!doctype html>', this.openTag('html', element)] ++
                (element.children |: $.render(this))).join(this.eol())

    func _applied_charset(element)
        element.checkNoChildren()
        meta: element.replaceTag('meta')
        charset: element.getOnlyArg(element, 'charset')
        if element.parent && element.parent.parent && element.parent.parent.isTag('html5')
            this.overrideAttrs(element, meta, {charset: charset}, {})
            return meta
        this.overrideAttrs(element, meta, {
            'http-equiv': 'Content-Type',
            content: 'text/html; charset=' + charset,
        }, {})
        return meta

    func _applied_jsfile(element)
        element.checkNoChildren()
        script: element.replaceTag('script')
        this.overrideAttrs(element, script, {
            type: 'text/javascript',
            src: element.getOnlyArg(element, 'file'),
        }, {})
        return script

    func _applied_cssfile(element)
        element.checkNoChildren()
        link: element.replaceTag('link')
        this.overrideAttrs(element, link, {
            rel: 'stylesheet',
            type: 'text/css',
            href: element.getOnlyArg(element, 'file'),
        }, {})
        return link

func renderHTMLBasis(text, variables)
    return HTMLBasisBuilder(variables).buildAndRenderTextSync(text)

export Builder: Builder
export HTMLBasisBuilder: HTMLBasisBuilder
export renderHTMLBasis: renderHTMLBasis

# Bootstrap & Font-awesome builder

class BootstrapFontawesomeBuilder: HTMLBasisBuilder
    ctor(variables) super(variables)
        0

    func overrideAttrsAsInput(src, dst, overrides, ignore)
        ignore.disabled: true
        this.overrideAttrs(src, dst, overrides, ignore)
        if src.argsKey.disabled || src.attributes.disabled
            dst.attr('disabled', 'disabled')

    func overrideAttrsAsBtn(src, dst, overrides, ignore)
        ignore.color: true
        overrides.type: src.attributes.type if src.attributes.type else 'button'
        this.overrideAttrsAsInput(src, dst, overrides, ignore)
        dst.addClass('btn')
        dst.addClass('btn-' + (src.attributes.color if src.attributes.color else 'default'))

    func _applied_btn(element)
        btn: element.replaceTag('button')
        this.overrideAttrsAsBtn(element, btn, {}, {})
        return btn

    func overrideAttrsAsFormCtl(src, dst, overrides, ignore)
        this.overrideAttrsAsInput(src, dst, overrides, ignore)
        dst.addClass('form-control')

    func _applied_input(element)
        i: element.replaceTag('input')
        this.overrideAttrsAsFormCtl(element, i, {type: 'text'}, {})
        return i

    func _applied_passwd(element)
        i: element.replaceTag('input')
        this.overrideAttrsAsFormCtl(element, i, {type: 'password'}, {})
        return i

    func _applied_textarea(element)
        i: element.replaceTag('textarea')
        this.overrideAttrsAsFormCtl(element, i, {}, {})
        return i

    func _applied_select(element)
        i: element.replaceTag('select')
        this.overrideAttrsAsFormCtl(element, i, {}, {})
        return i

    func _checkBoxApplied(element)
        self: this

        func inline()
            label: AppliedTagElement(element.parent, element.indentLevel, element.pos, 'label')
            label.addClass(element.tag + '-inline')
            input: element.replaceTag('input')
            input.indentLevel: label.indentLevel + 1 if input.children.length = 0
                                                     else input.children[0].indentLevel
            self.overrideAttrsAsInput(element, input, {type: element.tag}, {})
            label.append(input)
            input.children |: label.append($)
            input.children: []
            return label

        func block()
            root: AppliedTagElement(element.parent, element.indentLevel, element.pos, 'div')
            root.addClass(element.tag)
            if element.argsKey.disabled
                root.addClass('disabled')
            label: AppliedTagElement(element.parent, root.indentLevel + 1, element.pos, 'label')
            input: element.replaceTag('input')
            input.indentLevel: label.indentLevel + 1 if input.children.length = 0
                                                     else input.children[0].indentLevel
            self.overrideAttrsAsInput(element, input, {type: element.tag}, {})
            label.append(input)
            input.children |: label.append($)
            input.children: []
            root.append(label)
            return root

        return inline() if element.argsKey.inline else block()

    func _applied_checkbox(element)
        return this._checkBoxApplied(element)

    func _applied_radio(element)
        return this._checkBoxApplied(element)

    func _applied_container(element)
        c: element.replaceTag('div')
        c.addClass('container')
        return c

    func _applied_form_h(element)
        c: element.replaceTag('form')
        c.addClass('form-horizontal')
        c.addClass('form-submit')
        return c

    func _applied_row(element)
        c: element.replaceTag('div')
        c.addClass('form-group' if element.parent.isTag('form') ||
                                    element.parent.isTag('form-h') else 'row')
        return c

    func _firstOrCreate(parent, elements, tag, throwMsg)
        if elements.length = 0
            return AppliedTagElement(parent, parent.indentLevel + 1, parent.pos, tag)
        e: elements[0]
        if elements.length > 1 && throwMsg
            elements[1].throw_(throwMsg)
        return e

    func _firstOrNull(elements, throwMsg)
        if elements.length = 0
            return null
        e: elements[0]
        if elements.length > 1 && throwMsg
            elements[1].throw_(throwMsg)
        return e

    func _applied_modal(element)
        modal: element.replaceTag('div')
        modal.addClass('modal')
        modal.addClass('fade')
        this.overrideAttrs(element, modal, {
            role: 'dialog',
            tabindex: '-1',
            'aria-labelledby': '',
            'aria-hidden': 'true',
        }, {size: true})

        dialog: AppliedTagElement(modal, modal.indentLevel + 1, modal.pos, 'div')
        dialog.addClass('modal-dialog')
        dialog.addClass('modal-' + (element.attributes.size if element.attributes.size else 'lg'))
        content: AppliedTagElement(dialog, dialog.indentLevel + 1, dialog.pos, 'div')
        content.addClass('modal-content')
        dialog.append(content)

        head: this._firstOrCreate(content, modal.sliceChildren('head'), 'div',
                                  'more than 1 heads for modal')
        head.addClass('modal-header')
        content.append(head)

        body: this._firstOrCreate(content, modal.sliceChildren('body'), 'div',
                                  'more than 1 bodies for modal')
        body.addClass('modal-body')
        content.append(body)

        closeBtn: AppliedTagElement(head, head.indentLevel + 1, head.pos, 'button')
        closeBtn.addClass('close')
        closeBtn.attr('type', 'button')
        closeBtn.attr('data-dismiss', 'modal')
        closeBtn.append(TextLineElement(closeBtn, closeBtn.indentLevel + 1, closeBtn.pos,
                                        '&times;', (a): a))
        head.append(closeBtn)
        title: this._firstOrNull(modal.sliceChildren('title'), 'more than 1 titles for modal')
        if title != null
            title.tag: 'h4'
            title.addClass('modal-title')
            head.append(title)
        modal.children |: body.append($)
        modal.children: []
        modal.append(dialog)
        return modal

    func _applied_modal_toggle(element)
        toggle: element.replaceTag('button')
        this.overrideAttrsAsBtn(element, toggle, {
            'data-target': '#' + element.attributes.target,
            'data-toggle': 'modal',
        }, {target: true})
        return toggle

    func _applied_icon(element)
        element.checkNoChildren()
        t: element.replaceTag('i')
        t.addClass('fa')
        t.addClass('fa-' + element.getOnlyArg(element, 'icon'))
        return t

    func overrideAttrsAsGrid(src, dst, overrides, ignore)
        ignore.size: true
        ignore.offset: true
        if src.attributes.size > 0
            dst.addClass('col-sm-' + src.attributes.size)
        else
            dst.addClass('col-sm-4')
        if src.attributes.offset > 0
            dst.addClass('col-sm-offset-' + src.attributes.offset)
        this.overrideAttrs(src, dst, overrides, ignore)

    func _applied_grid(element)
        g: element.replaceTag('div')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_grid_s(element)
        g: element.replaceTag('label')
        g.addClass('form-control-static')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_grid_c(element)
        g: element.replaceTag('label')
        g.addClass('control-label')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_lbl(element)
        label: element.replaceTag('span')
        label.addClass('label')
        label.addClass('label-' + (element.attributes.color if element.attributes.color
                                                            else 'default'))
        this.overrideAttrs(element, label, {}, {color: true})
        return label

    func _applied_breadcrumb(element)
        if element.children.length = 0
            return element.replaceTag('div')
        bc: element.replaceTag('ol', false)
        this.overrideAttrs(element, bc, {}, {})
        bc.addClass('breadcrumb')
        for i range element.children.length - 1
            e: element.children[i]
            li: e.wrapReplaceIn('li', 'a')
            this.overrideAttrs(e, li.children[0], {}, {})
            bc.append(li)
        active: element.children[element.children.length - 1].replaceTag('li')
        active.addClass('active')
        bc.append(active)
        return bc

    func overrideAttrsAsAlert(src, dst, overrides, ignore)
        ignore.color: true
        ignore.dismiss: true
        this.overrideAttrs(src, dst, overrides, ignore)

    func _addAlertClasses(src, dst)
        dst.attributes.role: 'alert'
        dst.addClass('alert')
        dst.addClass('alert-' + (src.attributes.color if src.attributes.color else 'warning'))

    func _applyDismissableAlert(element)
        alr: element.wrapReplaceIn('div', 'div')
        this.overrideAttrsAsAlert(element, alr.children[0], {}, {})
        this._addAlertClasses(element, alr)
        alr.addClass('alert-dismissible')
        dismiss: AppliedTagElement(alr, alr.indentLevel + 1, alr.pos, 'button')
        dismiss.attributes: {
            type: 'button',
            'class': 'close',
            'data-dismiss': 'alert',
            'aria-label': 'Close',
        }
        close: AppliedTagElement(dismiss, dismiss.indentLevel + 1, dismiss.pos, 'span')
        close.attr('aria-hidden', 'true')
        close.append(TextLineElement(close, close.indentLevel + 1, close.pos, '&times;', (a): a))
        dismiss.append(close)
        alr.prepend(dismiss)
        return alr

    func _applied_alert(element)
        if element.argsKey.dismiss || element.attributes.dismiss
            return this._applyDismissableAlert(element)
        alr: element.replaceTag('div')
        this.overrideAttrsAsAlert(element, alr, {}, {})
        this._addAlertClasses(element, alr)
        return alr

func renderBootstrap(text, variables)
    return BootstrapFontawesomeBuilder(variables).buildAndRenderTextSync(text)

export BootstrapFontawesomeBuilder: BootstrapFontawesomeBuilder
export renderBootstrap: renderBootstrap

export __version__: '0.2.0 2015-1-19 Experimental'
