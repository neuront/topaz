class Exception
    ctor(line, message, type, object)
        this.line: line
        this.message: message
        this.type: type
        this.object: object

    func toString()
        return JSON.stringify({
            line: this.line,
            message: this.message,
            type: this.type,
            object: this.object,
        })

PATTERNS: [
    [/^[a-z_][0-9a-z_\-]*/i, 'ident'],

    [/^"([^"\\]*(\\.[^"\\]*)*)"/i, 'value', 'str'],
    [/^'([^'\\]*(\\.[^'\\]*)*)'/i, 'value', 'str'],
    [/^[0-9]+/, 'value', 'num'],
    [/^[0-9]*\.[0-9]+/, 'value', 'num'],

    [/^==/, 'op', 'eq'],
    [/^<=/, 'op', 'le'],
    [/^>=/, 'op', 'ge'],
    [/^!=/, 'op', 'ne'],
    [/^</, 'op', 'lt'],
    [/^>/, 'op', 'gt'],

    [/^&&/, 'op', 'and'],
    [/^\|\|/, 'op', 'or'],
    [/^!/, 'op', 'not'],

    [/^\+/, 'op', 'plus'],
    [/^\-/, 'op', 'minus'],
    [/^\*/, 'op', 'times'],
    [/^\//, 'op', 'div'],

    [/^=/, 'eq'],
    [/^#/, 'shp'],
    [/^\./, 'dot'],
    [/^%/, 'percentage'],
    [/^,/, 'comma'],
    [/^:/, 'colon'],

    [/^\(/, 'openparen'],
    [/^\)/, 'closeparen'],
    [/^\[/, 'openbracket'],
    [/^\]/, 'closebracket'],
    [/^\{/, 'openbrace'],
    [/^\}/, 'closebrace'],
]

class Token
    ctor(image, type, detail, line)
        this.image: image
        this.type: type
        this.detail: detail if detail else type
        this.line: line

    func throw_(msg)
        throw Exception(this.line, msg, 'token', this)

    func unexpected()
        this.throw_('Unexpected')

func tokenize(string, line)
    func tkz(string, result)
        func nextToken(string)
            PATTERNS |:
                r: $[0].exec(string)
                if r
                    return [Token(r[0], $[1], $[2], line), string.replace($[0], '').trimLeft()]
            throw Exception(line, 'Unexpected pattern', 'lex', string)

        if string.length = 0
            return result
        r: nextToken(string)
        result.push(r[0])
        return tkz(r[1], result)
    return tkz(string, [])

func testTrue(a)
    if typeof a = 'boolean'
        return a
    if typeof a = 'number'
        return a != 0 && !isNaN(a)
    a |:
        return true
    return false

func toString(a)
    if a = undefined || a = null
        return a + ''
    return a.toString()

class ValueBase
    ctor(line)
        this.line: line

    func empty()
        return false

    func apply(builder)
        return null

    func applyAsAttr(builder, element, attr)
        return element.attr(attr, this.apply(builder))

    func literal()
        this.throw_('Cannot convert to literal value')

    func test(builder)
        return testTrue(this.apply(builder))

    func throw_(msg)
        throw Exception(this.line, msg, 'value', this)

class EmptyExpr: ValueBase
    ctor(line) super(line)
        0

    func empty()
        return true

class LiteralValue: ValueBase
    ctor(line, v) super(line)
        this.value: v

    func apply(builder)
        return this.value

    func literal()
        return this.value

class NameValue: ValueBase
    ctor(line, n) super(line)
        this.name: n

    func apply(builder)
        return builder.getValue(this.name, this)

    func literal()
        return this.name

UNARY_OP_FUNC: {
    '+': (a): a,
    '-': (a): -a,
    '!': (a): !testTrue(a),
}

class UnaryOpValue: ValueBase
    ctor(line, opImage, rhs) super(line)
        this.op: UNARY_OP_FUNC[opImage]
        this.rhs: rhs

    func apply(builder)
        return this.op(this.rhs.apply(builder))

BINARY_OP_FUNC: {
    '+': (a, b): a + b,
    '-': (a, b): a - b,
    '*': (a, b): a * b,
    '/': (a, b): a / b,
    '%': (a, b): a % b,
    '==': (a, b): a = b,
    '!=': (a, b): a != b,
    '<=': (a, b): a <= b,
    '>=': (a, b): a >= b,
    '<': (a, b): a < b,
    '>': (a, b): a > b,
    '&&': (a, b): b if testTrue(a) else a,
    '||': (a, b): a if testTrue(a) else b,
}

class BinaryOpValue: ValueBase
    ctor(line, opImage, lhs, rhs) super(line)
        this.op: BINARY_OP_FUNC[opImage]
        this.lhs: lhs
        this.rhs: rhs

    func apply(builder)
        return this.op(this.lhs.apply(builder), this.rhs.apply(builder))

class MemberAccess: ValueBase
    ctor(line, lhs, rhs) super(line)
        this.lhs: lhs
        this.rhs: rhs.literal()

    func apply(builder)
        obj: this.lhs.apply(builder)
        if obj = undefined || obj = null
            this.throw_('Access property ' + this.rhs + ' from ' + obj)
        return obj[this.rhs]

class Lookup: ValueBase
    ctor(line, lhs, rhs) super(line)
        this.object: lhs
        this.key: rhs

    func apply(builder)
        obj: this.object.apply(builder)
        key: this.key.apply(builder)
        if obj = undefined || obj = null
            this.throw_('Lookup ' + key + ' from ' + obj)
        return obj[key]

class ListValue: ValueBase
    ctor(line, list) super(line)
        this.list: list

    func apply(builder)
        return this.list |: $.apply(builder)

class DictValue: ValueBase
    ctor(line, dict) super(line)
        this.dict: dict

    func apply(builder)
        r: {}
        this.dict |:
            r[$k]: $.apply(builder)
        return r

    func applyAsAttr(builder, element, attr)
        builder.applyDictForAttr(element, attr, this.dict)

class ConditionalValue: ValueBase
    ctor(line, predicate, consequence, alternative) super(line)
        this.pred: predicate
        this.consq: consequence
        this.alter: alternative

    func apply(builder)
        return this.consq.apply(builder) if this.pred.test(builder) else this.alter.apply(builder)

class ElementBase
    ctor(parent, indentLevel, line)
        this.parent: parent
        this.indentLevel: indentLevel
        this.line: line

    func append(child)
        this.throw_('Append an element to an unexpected place')

    func getAppendPoint(child)
        return this

    func render(r)
        this.throw_('Element base not renderable')

    func throw_(msg)
        throw Exception(this.line, msg, 'element', this)

    func findChildren(tag)
        return []

    func sliceChildren(tag)
        return []

    func isTag(tag)
        return false

    func isText()
        return false

    func attachElse(t)
        t.throw_('Else clause not match an if')

    func finish(builder)
        0

    func applyVariables(parent, builder, newIndent)
        return this

class CompoundElement: ElementBase
    ctor(parent, indentLevel, line) super(parent, indentLevel, line)
        this.children: []

    func append(child)
        if child
            this.children.push(child)

    func getAppendPoint(indentLevel)
        if indentLevel <= this.indentLevel
            return this.parent
        if this.children.length = 0
            return this
        return this.lastChild().getAppendPoint(indentLevel)

    func lastChild()
        return this.children[this.children.length - 1]

    func findChildren(tag)
        return this.children |? $.isTag(tag)

    func sliceChildren(tag)
        r: this.children |? $.isTag(tag)
        this.children: this.children |? !$.isTag(tag)
        return r

    func checkNoChildren()
        if this.children.length != 0
            this.throw_('Unexpected children for void element')

class FakeRoot: CompoundElement
    ctor() super(null, -1, -1)
        this.children: []

    func getAppendPoint(indentLevel)
        if this.children.length = 0
            return this
        return this.lastChild().getAppendPoint(indentLevel)

    func finish(builder)
        if this.children.length != 0
            this.lastChild().finish(builder)

class TagElementBase: CompoundElement
    ctor(parent, indentLevel, line, tag) super(parent, indentLevel, line)
        this.tag: tag
        this.attributes: {id: null}
        this.args: []
        this.argsKey: {}
        this.classes: []
        this.children: []

    func isTag(tag)
        return this.tag = tag

    func finish(builder)
        if this.children.length != 0
            this.lastChild().finish(builder)
        builder.onTagEnd(this)

    func getOnlyArg(forwhat)
        ifnot this.args && this.args.length = 1
            this.throw_('Require only one argument: ' + forwhat)
        return this.args[0]

class AppliedTagElement: TagElementBase
    ctor(parent, indentLevel, line, tag) super(parent, indentLevel, line, tag)
        0

    func arg(arg)
        if this.argsKey[arg]
            return
        this.args.push(arg)
        this.argsKey[arg]: true

    func attr(key, value)
        this.attributes[key]: value

    func setId(id)
        this.attributes.id: id

    func addClass(cls)
        this.classes.push(cls)

    func applyVariables(p, builder)
        return this

    func render(r)
        return r.renderTag(this)

    func replaceTag(tagName)
        e: AppliedTagElement(this.parent, this.indentLevel, this.line, tagName)
        this.classes |: e.addClass($)
        this.children |: e.append($)
        return e

class TagElement: TagElementBase
    ctor(parent, indentLevel, line, tag) super(parent, indentLevel, line, tag)
        0

    func arg(arg, line)
        if this.argsKey[arg]
            return
        this.args.push(LiteralValue(line, arg))
        this.argsKey[arg]: true

    func argExpr(expr)
        this.args.push(expr)

    func _setAttr(key, v)
        if this.attributes[key]
            this.throw_('Duplicate attribute: ' + key)
        this.attributes[key]: v

    func attr(key, value, line)
        if key = 'class'
            return value.split(' ') |: this.addClass($) if $.length != 0 else 0
        this._setAttr(key, LiteralValue(line, value))

    func attrExpr(key, expr)
        if key = 'class'
            return this.addClassExpr(expr)
        this._setAttr(key, expr)

    func setId(id, line)
        this.setIdExpr(LiteralValue(line, id))

    func setIdExpr(id)
        if this.attributes.id != null
            this.throw_('Duplicate id')
        this.attributes.id: id

    func addClass(cls, line)
        this.addClassExpr(LiteralValue(line, cls))

    func addClassExpr(cls)
        this.classes.push(cls)

    func applyVariables(parent, builder, newIndent)
        element: AppliedTagElement(parent,
                                   this.indentLevel
                                           if typeof newIndent = 'undefined'
                                           else newIndent,
                                   this.line, this.tag)
        this.attributes |:
            if $
                $.applyAsAttr(builder, element, $k)
        this.args |:
            r: $.apply(builder)
            if r
                element.arg(r)
        this.classes |:
            r: $.apply(builder)
            if r
                element.addClass(r)
        this.children |: element.append($.applyVariables(element, builder))
        return builder.onTagApplied(element)

class TextBase: ElementBase
    ctor(parent, indentLevel, line) super(parent, indentLevel, line)
        0

    func getAppendPoint(indentLevel)
        return this.parent

    func append(child)
        this.throw_('Unable to append to text')

    func isText()
        return true

class TextLineElement: TextBase
    ctor(parent, indentLevel, line, text, escape) super(parent, indentLevel, line)
        this.text: text
        this.escape: escape if escape else escapeText

    func render(r)
        return r.renderTextLine(this, null, this.escape)

class TextBlockElement: TextBase
    ctor(parent, indentLevel, line, lines, left, right, escape, eol) super(
            parent, indentLevel, line)
        this.lines: lines
        this.left: left
        this.right: right
        this.escape: escape
        this.eol: eol

    func render(r)
        return r.renderTextBlock(this)

class ValueElement: ElementBase
    ctor(parent, indentLevel, value) super(parent, indentLevel, value.line)
        this.value: value

    func getAppendPoint(indentLevel)
        return this.parent

    func append(child)
        this.throw_('Unable to append to text')

    func applyVariables(parent, builder, ni)
        value: this.value.apply(builder)
        return TextLineElement(
            this.parent, this.indentLevel if ni = undefined else ni, this.line, toString(value))

class IfElement: CompoundElement
    ctor(parent, indentLevel, predicate) super(parent, indentLevel, predicate.line)
        this.predicate: predicate
        this.consequence: this.children
        this.alternative: []

    func applyVariables(parent, builder, ni)
        newIndent: this.indentLevel if typeof ni = 'undefined' else ni
        if this.predicate.test(builder)
            this.consequence |: parent.append($.applyVariables(parent, builder, newIndent))
        else
            this.alternative |: parent.append($.applyVariables(parent, builder, newIndent))
        return null

    func attachElse(_)
        this.children: this.alternative

class ForElement: CompoundElement
    ctor(parent, indentLevel, keyName, elementName, object) super(parent, indentLevel, object.line)
        this.keyName: keyName
        this.elementName: elementName
        this.object: object

    func applyVariables(parent, builder, ni)
        newIndent: this.indentLevel if typeof ni = 'undefined' else ni
        this.object.apply(builder) |:
            if this.keyName
                builder.setValue(this.keyName, $k)
            builder.setValue(this.elementName, $)
            this.children |: parent.append($.applyVariables(parent, builder, newIndent))
        return null

class Automation
    ctor(stack)
        this.stack: stack

    func activated()
        0

    func push(token)
        f: '_push_' + token.type
        if this[f]
            return this[f](token)
        token.unexpected()

    func setPushFunc(tokenType, fn)
        self: this
        self['_push_' + tokenType]: (token): fn(self, token)

    func reduced(expr)
        throw 'Unimplemented expr'

    func addLine(string, lineno)
        this.stack.consume(tokenize(string.trim(), lineno))

    func finish()
        this.stack.pop()

    func finished()
        return true

    func forceFinish()
        this.finish()

UNARY_OP_PRI: {
    '!': 2,
    '+': 6,
    '-': 6,
}

BINARY_OP_PRI: {
    '||': 0,
    '&&': 1,

    '==': 3,
    '!=': 3,
    '<=': 3,
    '>=': 3,
    '<': 3,
    '>': 3,

    '+': 4,
    '-': 4,

    '*': 5,
    '/': 5,
    '%': 5,

    '.': 7,
}

KEYWORDS: {
    'for': true,
    'in': true,
    'if': true,
    'else': true,
}

class DynamicDataAutomationBase: Automation
    ctor(stack) super(stack)
        0

    func _push_ident(token)
        if KEYWORDS[token.image]
            f: '_pushkw_' + token.image
            if this[f]
                return this[f](token)
            token.type: 'keyword'
            token.detail: 'keyword'
            return token.unexpected()
        this._pushIdent(token)

class ArithAutomation: DynamicDataAutomationBase
    ctor(stack, line, allowEmpty) super(stack)
        this._needFactor: true
        this._exprStack: []
        this._opStack: []
        this.line: line
        this.allowEmpty: allowEmpty
        ['comma', 'closeparen', 'closebracket', 'closebrace'] |: this._setFollowing($)

    func _setFollowing(tokenType)
        this.setPushFunc(tokenType, (self, token): self._finishAt(token))

    func _pushkw_else(token)
        this._finishAt(token)

    func _finishAt(token)
        if this._empty() && this.allowEmpty
            return this.stack.tokenAfterReduced(EmptyExpr(token.line), token)
        if this._exprStack.length = 0
            token.unexpected()
        this.finish()
        this.stack.top().push(token)

    func finish()
        this._reduceBinary(-1)
        this.stack.reduced(this._exprStack[0])

    func finished()
        return !this._needFactor

    func _empty()
        return this._exprStack.length = 0 && this._opStack.length = 0

    func forceFinish()
        ifnot this.finished()
            throw Exception(this.line, 'Unexpected EOF', 'am', this)
        this.finish()

    func _push_dot(token)
        token.type: 'op'
        token.construct: (exprStack):
            rhs: exprStack.shift()
            lhs: exprStack.shift()
            return MemberAccess(token.line, lhs, rhs)
        return this._push_op(token)

    func _push_percentage(token)
        token.type: 'op'
        return this._push_op(token)

    func _push_op(token)
        if this._needFactor
            return this._pushUnaryOp(token)
        token.construct: token.construct if token.construct else (exprStack):
            rhs: exprStack.shift()
            lhs: exprStack.shift()
            return BinaryOpValue(token.line, token.image, lhs, rhs)
        token.pri: BINARY_OP_PRI[token.image]
        this._reduceBinary(token.pri)
        this._opStack.unshift(token)
        this._needFactor: true

    func _pushUnaryOp(token)
        pri: UNARY_OP_PRI[token.image]
        if pri = undefined
            token.throw_('Unexpected operator')
        token.pri: pri
        token.construct: (exprStack):
            rhs: exprStack.shift()
            return UnaryOpValue(token.line, token.image, rhs)
        this._opStack.unshift(token)

    func _reduceBinary(currentOpPri)
        if this._opStack.length = 0
            return
        if this._opStack[0].pri >= currentOpPri
            top: this._opStack.shift()
            this._exprStack.unshift(top.construct(this._exprStack))
            this._reduceBinary(currentOpPri)

    func _pushIdent(token)
        return this._pushFactor(token, NameValue)

    func _push_value(token)
        if token.detail = 'num'
            return this._pushFactor(token, (ln, i): LiteralValue(ln, parseFloat(i)))
        if token.detail = 'str'
            return this._pushFactor(token, (ln, i): LiteralValue(ln, eval(i)))
        return this._pushFactor(token, LiteralValue)

    func _pushValue(value)
        this._needFactor: false
        this._exprStack.unshift(value)

    func _pushFactor(token, construct)
        ifnot this._needFactor
            token.unexpected()
        this._pushValue(construct(token.line, token.image))

    func _push_openparen(token)
        ifnot this._needFactor
            token.unexpected()
        this.stack.push(ArithWrapAutomation(this.stack, token.line, 'closeparen', ')'))
        self: this
        self.reduced: (expr): self._pushValue(expr)

    func _push_openbracket(token)
        self: this
        if self._needFactor
            self.reduced: (expr): self._pushValue(expr)
            return this.stack.push(ListAutomation(this.stack, token.line, 'closebracket', ']'))
        this.stack.push(ArithWrapAutomation(this.stack, token.line, 'closebracket', ']'))
        this.needFactor: false
        self.reduced: (expr):
            t: Token('.', 'op', 'lookup', token.line)
            t.construct: (exprStack):
                rhs: exprStack.shift()
                lhs: exprStack.shift()
                return Lookup(token.line, lhs, rhs)
            self._push_op(t)
            self._pushValue(expr)

    func _pushkw_if(token)
        if this._needFactor
            token.unexpected()
        this._reduceBinary(-1)
        e: this._exprStack.pop()
        this.stack.push(ConditionalExprAutomation(this.stack, token.line, e))
        self: this
        self.reduced: (expr): self._pushValue(expr)

class ArithWrapAutomation: DynamicDataAutomationBase
    ctor(stack, line, closerType, closerImage) super(stack)
        this.line: line
        this.closeReport: ', expect ' + closerImage
        this.setPushFunc(closerType, (self, token): self.finish())
        this._expr: null

    func activated()
        this.stack.push(ArithAutomation(this.stack, this.line))

    func reduced(expr)
        this._expr: expr

    func finish()
        this.stack.reduced(this._expr)

    func finished()
        return false

    func _push_closeparen(token)
        token.throw_('Mismatch parenthesis' + this.closeReport)

    func _push_closebracket(token)
        token.throw_('Mismatch parenthesis' + this.closeReport)

    func _push_closebrace(token)
        token.throw_('Mismatch parenthesis' + this.closeReport)

    func forceFinish()
        throw Exception(this.line, 'Unexpected EOF' + this.closeReport, 'am', this)

class ConditionalExprAutomation: DynamicDataAutomationBase
    ctor(stack, line, consq) super(stack)
        this.line: line
        this._predicate: null
        this._consequence: consq

    func reduced(expr)
        self: this
        self._predicate: expr
        self._pushkw_else: (token):
            self.stack.push(ArithAutomation(self.stack, token.line))
            self.reduced: (expr): self.finish(expr)

    func activated()
        this.stack.push(ArithAutomation(this.stack, this.line))

    func finish(expr)
        this.stack.reduced(ConditionalValue(this.line, this._predicate, this._consequence, expr))

class ListAutomation: ArithWrapAutomation
    ctor(stack, line, closerType, closerImage) super(stack, line, closerType, closerImage)
        this._expr: ListValue(line, [])

    func activated()
        this.stack.push(ArithAutomation(this.stack, this.line, true))

    func _push_comma()
        this.activated()

    func reduced(expr)
        ifnot expr.empty()
            this._expr.list.push(expr)

class DictItemAutomation: DynamicDataAutomationBase
    ctor(stack, dictVal) super(stack)
        this._name: null
        this._dictVal: dictVal

    func _pushIdent(token)
        this._name: token.image

    func _push_value(token)
        this._name: eval(token.image).toString()

    func _push_colon(token)
        this.stack.push(ArithAutomation(this.stack, token.line))

    func reduced(expr)
        this._dictVal[this._name]: expr
        this.finish()

    func _push_closebrace(token)
        if this._name = null
            this.finish()
            return this.stack.top().push(token)
        token.throw_('Expect item value')

    func finished()
        return false

class DictAutomation: ArithWrapAutomation
    ctor(stack, line, closerType, closerImage) super(stack, line, closerType, closerImage)
        this._expr: DictValue(line, {})
        this._key: null

    func activated()
        this.stack.push(DictItemAutomation(this.stack, this._expr.dict))

    func _push_comma()
        this.activated()

class ForHeadAutomation: DynamicDataAutomationBase
    ctor(forToken, stack, parent) super(stack)
        this.forToken: forToken
        this.parent: parent
        this.declares: []
        this._init()

    func _init()
        self: this
        self._pushIdent: (token): self._pushDeclare(token)
        self._push_comma: (token): token.unexpected()

    func _pushkw_in(token)
        if this.declares.length = 0 || this.declares.length > 2
            this.forToken.throw_('For loop expects 1 or 2 declared names, but '
                                 + this.declares.length)
        this.stack.push(ArithAutomation(this.stack, token.line))

        self: this
        self.reduced: (expr):
            if this.declares.length = 1
                self.parent.append(ForElement(
                            self.parent, self.stack.indentLevel,
                            null, this.declares[0], expr))
            else
                self.parent.append(ForElement(
                            self.parent, self.stack.indentLevel,
                            this.declares[0], this.declares[1], expr))
            self.stack.pop()

    func _waitComma()
        self: this
        self._pushIdent: (token): token.unexpected()
        self._push_comma: (token): self._init()

    func _pushDeclare(token)
        this.declares.push(token.image)
        this._waitComma()

    func finished()
        return false

    func forceFinish()
        this.forToken.throw_('Unexpected end of for loop')

class CtrlFlowAutomation: DynamicDataAutomationBase
    ctor(stack, parent) super(stack)
        this.parent: parent
        this._finished: false
        this._reduced: (_): 0

        ['value', 'op', 'openparen', 'openbracket'] |: this.setPushFunc(
                $, (self, t): self._pushExprAm(t))

    func finished()
        return this._finished

    func _pushkw_if(token)
        self: this
        self.stack.push(ArithAutomation(self.stack, token.line))
        self._reduced: (expr):
            self.parent.append(IfElement(self.parent, self.stack.indentLevel, expr))
            self._finished: true

    func _pushkw_for(token)
        this.stack.pop()
        this.stack.push(ForHeadAutomation(token, this.stack, this.parent))

    func _pushkw_else(token)
        ifnot this.parent.lastChild()
            token.throw_('Else clause not match an if')
        this.parent.lastChild().attachElse(token)
        this._finished: true

    func _pushExprAm(token)
        self: this
        self.stack.push(ArithAutomation(self.stack, token.line))
        self._reduced: (expr):
            self.parent.append(ValueElement(self.parent, self.stack.indentLevel, expr))
        self.stack.top().push(token)
        self._finished: true

    func _pushIdent(token)
        this._pushExprAm(token)

    func reduced(expr)
        return this._reduced(expr)

    func forceFinish()
        this.parent.throw_('''Unexpected `%' attached''')

class TagAutomation: Automation
    ctor(stack, element) super(stack)
        this.element: element
        this._lastKey: null
        this._restoreState()

    func reduced(expr)
        self: this
        self._reduced(expr)
        self._reduced: (): self.element.throw_('Unexpected expr')
        self._restoreState()

    func _allowOpenParen(reduced)
        self: this
        self._push_openparen: (token):
            self.stack.push(ArithWrapAutomation(self.stack, token.line, 'closeparen', ')'))
            self._reduced: reduced

    func _allowOpenBrace(reduced)
        self: this
        self._push_openbrace: (token):
            self.stack.push(DictAutomation(self.stack, token.line, 'closebrace', '}'))
            self._reduced: reduced

    func _restoreState()
        self: this
        self._forbidAll()
        self._setFinishable()
        self._push_value: (token): self.element.arg(eval(token.image), token.line)
        self._push_ident: (token): self._pushKey(token)
        self._push_shp: (): self._waitId()
        self._push_dot: (): self._waitClass()
        self._allowOpenParen((expr): self.element.argExpr(expr))

    func _forbidAll()
        this._push_ident: null
        this._push_value: null
        this._push_shp: null
        this._push_dot: null
        this._push_eq: null
        this._push_openparen: null

    func _setUnfinishable(expect)
        self: this
        self._finished: false
        self.finish: (): self.element.throw_('Unexpected end of line, expect ' + expect)

    func _setFinishable()
        self: this
        self._finished: true
        self.finish: (): self._finishAndAppend(false)

    func _finishAndAppend(lastKeyAsArg)
        if lastKeyAsArg
            this.element.arg(this._lastKey.image, this._lastKey.line)
        super.finish()
        if this.element.parent.children.length != 0
            this.element.parent.lastChild().finish(this.stack.builder)
        this.element.parent.append(this.element)
        this.stack.onTagBegin(this.element)

    func _pushKey(token)
        self: this
        self._forbidAll()
        self._lastKey: token
        self._push_eq: (): self._waitValue()
        self._push_value: (token):
            self.element.arg(self._lastKey.image, this._lastKey.line)
            self.element.arg(eval(token.image), token.line)
        self._push_ident: (token):
            self.element.arg(self._lastKey.image, this._lastKey.line)
            self._pushKey(token)
        self.finish: (): self._finishAndAppend(true)

    func _waitId()
        self: this
        self._forbidAll()
        self._push_ident: (token):
            self.element.setId(token.image, token.line)
            self._restoreState()
        self._setUnfinishable('ID')
        self._allowOpenParen((expr): self.element.setIdExpr(expr))

    func _waitClass()
        self: this
        self._forbidAll()
        self._push_ident: (token):
            self.element.addClass(token.image, token.line)
            self._restoreState()
        self._setUnfinishable('class')
        self._allowOpenParen((expr): self.element.addClassExpr(expr))

    func _waitValue()
        self: this
        self._forbidAll()
        self._push_ident: (token):
            self.element.attr(self._lastKey.image, token.image, token.line)
            self._restoreState()
        self._push_value: (token):
            self.element.attr(self._lastKey.image, eval(token.image), token.line)
            self._restoreState()
        self._setUnfinishable('attribute value')
        reducedValue: (expr): self.element.attrExpr(self._lastKey.image, expr)
        self._allowOpenParen(reducedValue)
        self._allowOpenBrace(reducedValue)

    func finished()
        return this._finished

    func forceFinish()
        ifnot this.finished()
            this.element.throw_('Unexpected finish of tag')
        this.finish()

_TEXTBLOCK_OPT_FUNCS: {
    left: {
        trim: (am): (ln): ln.trimLeft(),
        trunc: (am): (ln): ln[am.indentLevel, ],
        keep: (am): (ln): ln,
    },
    right: {
        trim: (am): (ln): ln.trimRight(),
        keep: (am): (ln): ln,
    },
    escape: {
        yes: escapeText,
        no: (ln): ln,
    },
    eol: {
        lf: '\n',
        off: '',
        br: '<br>',
    },
}

class TextBlockAutomation: Automation
    ctor(stack, appendPoint, line, indentLevel, escape) super(stack)
        this.appendPoint: appendPoint
        this.line: line
        this.indentLevel: indentLevel
        this._lines: []

        this._props: {
            left: false,
            right: false,
            escape: false,
            eol: false,
        }
        this._funcs: {
            left: _TEXTBLOCK_OPT_FUNCS.left.keep,
            right: _TEXTBLOCK_OPT_FUNCS.right.trim,
            escape: _TEXTBLOCK_OPT_FUNCS.escape['yes' if escape else 'no'],
            eol: _TEXTBLOCK_OPT_FUNCS.eol.lf,
        }
        this._lastProp: null

        this._waitProp()

    func _waitProp()
        self: this
        self._push_ident: (token):
            self._lastProp: token
            self._push_ident: (token): token.unexpected()
        self._push_eq: (token): self._waitValue()

    func _waitValue()
        self: this
        self._push_eq: (token): token.unexpected()
        self._push_ident: (token):
            self._setValue(token)
            self._waitProp()

    func _setValue(token)
        ifnot this._props.hasOwnProperty(this._lastProp.image)
            this._lastProp.throw_('Unknown option for text block')
        if this._props[this._lastProp.image]
            this._lastProp.throw_('Duplicated option for text block')
        this._props[this._lastProp.image]: true
        f: _TEXTBLOCK_OPT_FUNCS[this._lastProp.image][token.image]
        ifnot f
            token.throw_('Invalid option value for text block')
        this._funcs[this._lastProp.image]: f
        this._lastProp: null

    func addLine(string, lineno)
        if this._lastProp != null
            this._lastProp.throw_('Option not set for text block')
        if string.trimLeft() = ':::'
            return this.finish()
        if this.indentLevel = undefined
            this.indentLevel = indentLv(string)
        this._lines.push(string)

    func finish()
        this.appendPoint.append(TextBlockElement(
            this.appendPoint, this.stack.indentLevel, this.line, this._lines,
            this._funcs.left(this), this._funcs.right(this),
            this._funcs.escape, this._funcs.eol))
        super.finish()

    func finished()
        return false

_TEXTBLOCK_PATTERN: /^:::/
_TEXT_PATTERN: /^:.+$/

class BootstrapAutomation: Automation
    ctor(stack, appendPoint) super(stack)
        this.appendPoint: appendPoint

    func addLine(string, lineno)
        strim: string.trimLeft()
        if _TEXTBLOCK_PATTERN.exec(strim)
            this.stack.push(TextBlockAutomation(
                this.stack, this.appendPoint, lineno, this.stack.indentLevel, true))
            return this.stack.consume(tokenize(strim.slice(3).trim(), lineno))
        if _TEXT_PATTERN.exec(strim)
            return this.appendPoint.append(TextLineElement(
                this.appendPoint, this.stack.indentLevel, lineno, strim.slice(1)))
        super.addLine(string, lineno)

    func _push_ident(token)
        this.stack.push(TagAutomation(this.stack, TagElement(
            this.appendPoint, this.stack.indentLevel, token.line, token.image)))

    func _push_percentage(token)
        this.stack.push(CtrlFlowAutomation(this.stack, this.appendPoint))

class AutomationStack
    ctor(appendPoint, indentLevel, builder)
        this.indentLevel: indentLevel
        this.stack: [BootstrapAutomation(this, appendPoint)]
        this.builder: builder

    func top()
        return this.stack[this.stack.length - 1]

    func push(a)
        this.stack.push(a)
        a.activated()

    func reduced(expr)
        this.pop()
        this.top().reduced(expr)

    func tokenAfterReduced(expr, token)
        this.reduced(expr)
        this.top().push(token)

    func pop()
        return this.stack.pop()

    func consume(tokens)
        tokens |: this.top().push($)

    func addLine(string, line)
        this.top().addLine(string, line)

    func tryFinish()
        if this.stack.length = 0
            return true
        if this.top().finished()
            this.top().finish()
            return this.tryFinish()
        return false

    func forceFinish()
        if this.stack.length != 0
            this.top().forceFinish()
            this.forceFinish()

    func onTagBegin(element)
        return this.builder.onTagBegin(element, this)

# http://www.w3.org/TR/2011/WD-html-markup-20110113/syntax.html#void-element
VOID_ELEMENTS: {
    area: true,
    base: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
}

ESCAPE_RE: /[<>'"&]/g

func escapeText(s)
    return s.replace(ESCAPE_RE, (r): '&#' + r.charCodeAt(0) + ';')

INDENT_RE: *RegExp('^[ ]*')

func indentLv(string)
    return INDENT_RE.exec(string)[0].length

func _findFuncName(prefix, tag)
    return prefix + tag.replace(/-/g, '_')

class Builder
    ctor(variables)
        this.variables: variables if variables else {}
        this.reset()

    func reset()
        this.lines: 0
        this._root: FakeRoot()
        this._stack: null

    func getElements()
        return this._root.children

    func buildAndRenderText(text)
        return this.applyAndRender(this.buildTextToElements(text))

    func buildTextToElements(text)
        text.split('\n') |: this.addLine($)
        this.finish()
        r: this.getElements()
        this.reset()
        return r

    func applyVariablesTo(elements)
        root: FakeRoot()
        elements |: root.append($.applyVariables(root, this))
        return root.children

    func applyVariablesToOwn()
        return this.applyVariablesTo(this.getElements())

    func renderApplied(elements)
        return (elements |: $.render(this)).join(this.eol())

    func applyAndRender(elements)
        return this.renderApplied(this.applyVariablesTo(elements))

    func applyAndRenderOwn(elements)
        return this.applyAndRender(this.getElements())

    func getAppendPoint(indentLevel)
        return this._root.getAppendPoint(indentLevel)

    func _applyDictForData(element, dictVal)
        dictVal |: element.attr('data-' + $k, $.apply(this).toString())

    func _applyDictForStyle(element, dictVal)
        element.attr('style', (dictVal |: [$k, $.apply(this)].join(':')).join(';'))

    func applyDictForAttr(element, attr, dictVal)
        if attr = 'data'
            return this._applyDictForData(element, dictVal)
        if attr = 'style'
            return this._applyDictForStyle(element, dictVal)
        return this.applyDictForCustomAttr(element, attr, dictVal)

    func applyDictForCustomAttr(element, attr, dictVal)
        dictVal.throw_('Dict value not handled for ' + attr + ' of ' + element.tag)

    func _initStackIfNull(indentLevel)
        self: this
        func applyStack()
            self._stack: AutomationStack(
                self.getAppendPoint(indentLevel), indentLevel, self)

        if this._stack = null
            return applyStack()
        if indentLevel < this._stack.indentLevel
            this._stack.forceFinish()
            return applyStack()

    func addLine(string)
        this.lines: this.lines + 1
        return this.addLineWithLevel(string, indentLv(string))

    func addLineWithLevel(string, indentLevel)
        this._initStackIfNull(indentLevel)
        this._stack.addLine(string, this.lines)
        if this._stack.tryFinish()
            this._stack: null

    func finish()
        if this._stack
            this._stack.forceFinish()
        this._root.finish(this)

    func onTagBegin(element, stack)
        f: _findFuncName('_ontagbegin_', element.tag)
        if this[f]
            this[f](element, stack)

    func onTagEnd(element)
        f: _findFuncName('_ontagend_', element.tag)
        if this[f]
            this[f](element)

    func onTagApplied(element)
        f: _findFuncName('_applied_', element.tag)
        return this[f](element) if this[f] else element

    func setAppliedFunc(tagname, f)
        self: this
        self[_findFuncName('_applied_', tagname)]: (element): f(element, self)

    func overrideAttrs(src, dst, overrides, ignore)
        src.attributes |:
            if overrides.hasOwnProperty($k)
                continue
            ifnot ignore[$k]
                dst.attr($k, $)
        overrides |: dst.attr($k, $)

    func repeatStr(s, times)
        if !times
            return ''
        return Array(times + 1).join(s)

    func indent(indentLevel)
        return this.repeatStr(' ', indentLevel)

    func eol()
        return '\n'

    func renderTextLine(element, o, esc)
        return this.indent(element.indentLevel) + esc(element.text)

    func renderTextBlock(element)
        return (element.lines |: element.right(element.left(element.escape($)))).join(element.eol)

    func renderTag(element)
        f: _findFuncName('_rendertag_', element.tag)
        if this[f]
            return this[f](element)
        if VOID_ELEMENTS[element.tag]
            element.checkNoChildren()
            return this.renderVoid(element.tag, element)
        return this.renderNonvoid(element.tag, element)

    func renderNonvoid(tag, element)
        return ([this.openTag(tag, element)] ++
                (element.children |: $.render(this)) ++
                [this.closeTag(tag, element.indentLevel)]
               ).join(this.eol())

    func renderVoid(tag, element)
        return this.openTag(tag, element)

    func renderInline(tag, element)
        return this.openTag(tag, element) + this.closeTag(tag)

    func renderInlineWithText(tag, element, text)
        return this.openTag(tag, element) + text + this.closeTag(tag)

    func renderClasses(cls)
        return '' if cls.length = 0 else (' class="' + cls.join(' ') + '"')

    func renderAttrs(attrs)
        return (attrs |:
            if $ != null && $ != undefined
                $result.push(' ', $k, '=', JSON.stringify($.toString()))
        ).join('')

    func openTag(tag, elm)
        return this.indent(elm.indentLevel) + '<' + tag +
            this.renderClasses(elm.classes) + this.renderAttrs(elm.attributes) + '>'

    func closeTag(tag, indentLevel)
        return this.indent(indentLevel) + '</' + tag + '>'

    func setRenderFunc(tagname, f)
        self: this
        self[_findFuncName('_rendertag_', tagname)]: (element): f(element, self)

    func getValue(name)
        return this.variables[name]

    func setValue(name, value)
        this.variables[name]: value

    func resetVariables(variables)
        this.variables: variables

class HTMLBasisBuilder: Builder
    ctor(variables) super(variables)
        0

    func _pushTextReceiver(stack, element)
        class ActiveTextBlockAutomation: TextBlockAutomation
            ctor() super(stack, element, element.line)
                self: this
                self.addLine: (s): self._add1stLine(s)

            func _add1stLine(string)
                self: this
                indent: indentLv(string)
                if indent < element.indentLevel
                    element.throw_('Invalid content indent level')
                self._lines.push(string)
                self.stack.indentLevel: indent
                self.addLine: (s): self._addLine(s)

            func _addLine(string)
                this._lines.push(string)

        stack.push(ActiveTextBlockAutomation())

    func _ontagbegin_js(element, stack)
        this._pushTextReceiver(stack, element)
        element.tag: 'script'
        element.attributes.type: LiteralValue(element.line, 'text/javascript')

    func _ontagbegin_css(element, stack)
        this._pushTextReceiver(stack, element)
        element.tag: 'style'

    func _rendertag_html5(element)
        return (['<!doctype html>', this.openTag('html', element)] ++
                (element.children |: $.render(this))).join(this.eol())

    func _applied_charset(element)
        element.checkNoChildren()
        meta: element.replaceTag('meta')
        charset: element.getOnlyArg(element, 'charset')
        if element.parent && element.parent.parent && element.parent.parent.isTag('html5')
            this.overrideAttrs(element, meta, {charset: charset}, {})
            return meta
        this.overrideAttrs(element, meta, {
            'http-equiv': 'Content-Type',
            content: 'text/html; charset=' + charset,
        }, {})
        return meta

    func _applied_jsfile(element)
        element.checkNoChildren()
        script: element.replaceTag('script')
        this.overrideAttrs(element, script, {
            type: 'text/javascript',
            src: element.getOnlyArg(element, 'file'),
        }, {})
        return script

    func _applied_cssfile(element)
        element.checkNoChildren()
        link: element.replaceTag('link')
        this.overrideAttrs(element, link, {
            rel: 'stylesheet',
            type: 'text/css',
            href: element.getOnlyArg(element, 'file'),
        }, {})
        return link

func renderHTMLBasis(text, variables)
    return HTMLBasisBuilder(variables).buildAndRenderText(text)

export Builder: Builder
export HTMLBasisBuilder: HTMLBasisBuilder
export renderHTMLBasis: renderHTMLBasis

# Bootstrap & Font-awesome builder

class BootstrapFontawesomeBuilder: HTMLBasisBuilder
    ctor(variables) super(variables)
        0

    func overrideAttrsAsInput(src, dst, overrides, ignore)
        ignore.disabled: true
        this.overrideAttrs(src, dst, overrides, ignore)
        if src.argsKey.disabled || src.attributes.disabled
            dst.attr('disabled', 'disabled')

    func overrideAttrsAsBtn(src, dst, overrides, ignore)
        ignore.color: true
        overrides.type: src.attributes.type if src.attributes.type else 'button'
        this.overrideAttrsAsInput(src, dst, overrides, ignore)
        dst.addClass('btn')
        dst.addClass('btn-' + (src.attributes.color if src.attributes.color else 'default'))

    func _applied_btn(element)
        btn: element.replaceTag('button')
        this.overrideAttrsAsBtn(element, btn, {}, {})
        return btn

    func overrideAttrsAsFormCtl(src, dst, overrides, ignore)
        this.overrideAttrsAsInput(src, dst, overrides, ignore)
        dst.addClass('form-control')

    func _applied_input(element)
        i: element.replaceTag('input')
        this.overrideAttrsAsFormCtl(element, i, {type: 'text'}, {})
        return i

    func _applied_passwd(element)
        i: element.replaceTag('input')
        this.overrideAttrsAsFormCtl(element, i, {type: 'password'}, {})
        return i

    func _applied_textarea(element)
        i: element.replaceTag('textarea')
        this.overrideAttrsAsFormCtl(element, i, {}, {})
        return i

    func _applied_select(element)
        i: element.replaceTag('select')
        this.overrideAttrsAsFormCtl(element, i, {}, {})
        return i

    func _checkBoxApplied(element)
        self: this

        func inline()
            label: AppliedTagElement(element.parent, element.indentLevel, element.line, 'label')
            label.addClass(element.tag + '-inline')
            input: element.replaceTag('input')
            input.indentLevel: label.indentLevel + 1 if input.children.length = 0
                                                     else input.children[0].indentLevel
            self.overrideAttrsAsInput(element, input, {type: element.tag}, {})
            label.append(input)
            input.children |: label.append($)
            input.children: []
            return label

        func block()
            root: AppliedTagElement(element.parent, element.indentLevel, element.line, 'div')
            root.addClass(element.tag)
            if element.argsKey.disabled
                root.addClass('disabled')
            label: AppliedTagElement(element.parent, root.indentLevel + 1, element.line, 'label')
            input: element.replaceTag('input')
            input.indentLevel: label.indentLevel + 1 if input.children.length = 0
                                                     else input.children[0].indentLevel
            self.overrideAttrsAsInput(element, input, {type: element.tag}, {})
            label.append(input)
            input.children |: label.append($)
            input.children: []
            root.append(label)
            return root

        return inline() if element.argsKey.inline else block()

    func _applied_checkbox(element)
        return this._checkBoxApplied(element)

    func _applied_radio(element)
        return this._checkBoxApplied(element)

    func _applied_container(element)
        c: element.replaceTag('div')
        c.addClass('container')
        return c

    func _applied_form_h(element)
        c: element.replaceTag('form')
        c.addClass('form-horizontal')
        c.addClass('form-submit')
        return c

    func _applied_row(element)
        c: element.replaceTag('div')
        c.addClass('form-group' if element.parent.isTag('form') ||
                                    element.parent.isTag('form-h') else 'row')
        return c

    func _firstOrCreate(parent, elements, tag, throwMsg)
        if elements.length = 0
            return AppliedTagElement(parent, parent.indentLevel + 1, parent.line, tag)
        e: elements[0]
        if elements.length > 1 && throwMsg
            elements[1].throw_(throwMsg)
        return e

    func _firstOrNull(elements, throwMsg)
        if elements.length = 0
            return null
        e: elements[0]
        if elements.length > 1 && throwMsg
            elements[1].throw_(throwMsg)
        return e

    func _applied_modal(element)
        modal: element.replaceTag('div')
        modal.addClass('modal')
        modal.addClass('fade')
        this.overrideAttrs(element, modal, {
            role: 'dialog',
            tabindex: '-1',
            'aria-labelledby': '',
            'aria-hidden': 'true',
        }, {size: true})

        dialog: AppliedTagElement(modal, modal.indentLevel + 1, modal.line, 'div')
        dialog.addClass('modal-dialog')
        dialog.addClass('modal-' + (element.attributes.size if element.attributes.size else 'lg'))
        content: AppliedTagElement(dialog, dialog.indentLevel + 1, dialog.line, 'div')
        content.addClass('modal-content')
        dialog.append(content)

        head: this._firstOrCreate(content, modal.sliceChildren('head'), 'div',
                                  'more than 1 heads for modal')
        head.addClass('modal-header')
        content.append(head)

        body: this._firstOrCreate(content, modal.sliceChildren('body'), 'div',
                                  'more than 1 bodies for modal')
        body.addClass('modal-body')
        content.append(body)

        closeBtn: AppliedTagElement(head, head.indentLevel + 1, head.line, 'button')
        closeBtn.addClass('close')
        closeBtn.attr('type', 'button')
        closeBtn.attr('data-dismiss', 'modal')
        closeBtn.append(TextLineElement(closeBtn, closeBtn.indentLevel + 1, closeBtn.line, '&times;', (a): a))
        head.append(closeBtn)
        title: this._firstOrNull(modal.sliceChildren('title'), 'more than 1 titles for modal')
        if title != null
            title.tag: 'h4'
            title.addClass('modal-title')
            head.append(title)
        modal.children |: body.append($)
        modal.children: []
        modal.append(dialog)
        return modal

    func _applied_modal_toggle(element)
        toggle: element.replaceTag('button')
        this.overrideAttrsAsBtn(element, toggle, {
            'data-target': '#' + element.attributes.target,
            'data-toggle': 'modal',
        }, {target: true})
        return toggle

    func _applied_icon(element)
        element.checkNoChildren()
        t: element.replaceTag('i')
        t.addClass('fa')
        t.addClass('fa-' + element.getOnlyArg(element, 'icon'))
        return t

    func overrideAttrsAsGrid(src, dst, overrides, ignore)
        ignore.size: true
        ignore.offset: true
        if src.attributes.size > 0
            dst.addClass('col-sm-' + src.attributes.size)
        else
            dst.addClass('col-sm-4')
        if src.attributes.offset > 0
            dst.addClass('col-sm-offset-' + src.attributes.offset)
        this.overrideAttrs(src, dst, overrides, ignore)

    func _applied_grid(element)
        g: element.replaceTag('div')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_grid_s(element)
        g: element.replaceTag('label')
        g.addClass('form-control-static')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_grid_c(element)
        g: element.replaceTag('label')
        g.addClass('control-label')
        this.overrideAttrsAsGrid(element, g, {}, {})
        return g

    func _applied_lbl(element)
        label: element.replaceTag('span')
        label.addClass('label')
        label.addClass('label-' + (element.attributes.color if element.attributes.color
                                                            else 'default'))
        this.overrideAttrs(element, label, {}, {color: true})
        return label

func renderBootstrap(text, variables)
    return BootstrapFontawesomeBuilder(variables).buildAndRenderText(text)

export BootstrapFontawesomeBuilder: BootstrapFontawesomeBuilder
export renderBootstrap: renderBootstrap

export __version__: '0.2.0 2015-1-29 Experimental'
